<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Labyrinth of Tolgarith</title>
    <style>
        *{
            box-sizing: border-box;
            margin:auto;
            position:relative;
            font-family: monospace;
        }


        html,body{
            margin:0px;
            width:100%;
            height:100%;
        }

        p, div{
            line-height: 1.5em;
        }

        canvas{
            image-rendering: pixelated;
        }

        button{
            margin:5px;
            padding:10px;
            border:none;
            background:#000;
            color:#fff;
        }
        
        p{
            margin:25px;
        }

        body{
            text-align:left;
        }

        hr{
            margin:20px 0px;
            border:none;
            border-bottom:solid 1px #000;
        }

        h1{
            margin:10px 0px;
            position:fixed;
            bottom:10px;
            right:25px;
            opacity:0.25;
        }

        tr,td,table{
            border:solid 1px #000;
            border-collapse: collapse;
        }

        table{
            margin:10px;
        }

        td{
            padding:5px;

        }

        .page{
            padding:10px;
            margin:10px;
            display:block;
            width:calc(100% - 20px);
            min-height:90%;
            border:solid 1px #000;
        }

        .hpContainer{
            display:flex;
            width:fit-content;
        }

        .hpContainer button{
            background:hsl(0,50%,50%);
        }

        #optionsContainer{
            display:flex;
            margin:10px;
            text-align:left;
            width:fit-content;
        }

        .gold{
            height:37px;
            padding:5px;
            outline:none;
            margin:5px;
            text-align:center;
            border:solid 1px #000;
        }

        .inventory{
            display:flex;
            float:right;
            height:800px;
            width:200px;
            outline:none;
            padding:10px;
            z-index:9999;
        }

        .board{
            border:solid 1px #000;
            margin:auto;
        }

        .game{
            margin:auto;
            text-align:center;
        }

        tr:nth-child(1){
            font-weight: bold;
        }

        .tileButton{
            font-size:64px;
            width:100px;
            height: 100px;
            border-radius:100px;
            border:solid 1px #000;
        }

        .tileButton:hover{
            background:#fff;
        }

        .log{
            padding:10px;
            font-family: monospace;
            margin:10px;
            border:solid 1px #000;
            height:800px;
            width:200px;
            overflow: auto;
            outline:none;
            line-height: 1.8em;
        }

        .monsterInfo{
            min-width:200px;
            border:solid 1px #000;
            display:inline-block;
            padding:10px;
            margin:5px;
            text-align:left;
        }

        @media print{
            #optionsContainer{
                display:none;
            }

            .page{

                width:8.5in;
                height:11in;
                border:none;
                padding:auto;
                margin:auto;
            }

            td{
                font-size:8px;
            }
            
            table,tr,td{
                border:solid 1px #000 !important;
            }

            table{
                margin:25px;
            }

            h2{
                font-size:16px;
                margin:25px;
            }

            .noprint{
                display:none;
            }
        }

    </style>
    <script src="gerosoup.js"></script>
</head>
<body>


    <h1>The Labyrinth of Tolgarith</h1>
    <!--
    <div class="page">
    <table>
        <tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
        <tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
        <tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
        <tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
        <tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
        <tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
        <tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
        <tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
    </table>
    -->

    <!--
    <div class="page">

        <pre>

            <b>Board Setup</b>

            Forest
                scatter rocks and crates, no long corridors or rooms

            Cave
                scatter rocks and crates, with long corridors, no rooms

            Village
                rooms and corridors with crates

            Castle
            TBD

            At the start you have a monster budget of 1, increasing by 1 per level (resetting at each area) and + 1 per area
            roll a D6 to determine what monster you fight and subtract it's cost from the budget for that round, continue to roll into you use up your budget, 
            the budget recalculates on the next level

            <b>Combat</b>

            the player(s) always move first, on your turn you can 
            
            move
            attack (consumes action)
            short rest (consumes action)
            long rest (consumes turn)
            change equipment (consumes action, can change everything in 1 turn)
            skip turn (consumes turn)

            you defeat an enemy by rolling their armor level or higher

            dumb enemies mindlessly charge at the nearest player, happily stepping on traps along the way
            mid enemies will only step on traps under certain circumstance but will otherwise charge the nearest player
            smart enemies will always avoid traps unless specified and will keep in the ideal range for their weapon, moving, attacking and moving away if possible

            enemy skills are listed by order, they will try and use the first ability that has an effect, moving through the list until something will hit 

            upon killing an enemy, roll a d4 if greater that 2, place a chest at their location, on pickup, roll a d4, 1-2 is D20 money, 3 is D20 Item, and 4 is D20 weapon
            
            if your hp is above 3 and you receive a strike that would kill you, you are still alive but must short rest within the next 5 turns

            every 5 levels before the enemies spawn a random merchant will appear, roll a d4 to decide

            1, 2 - traveling merchant, roll 4D20, they sells 3 items and 1 weapon, you can also sell to them

            3 - traveling scholar, roll 4D20, they sells 2 items and 2 spells, you can also sell to them

            4 - mysterious shadow, they sell all the items you've had on this and previous runs for 1.5x price 

            <hr>

        </pre>
    </div>
    -->

    <div id="optionsContainer"></div>
    <div id="monsterButtonList"></div>
</div>
    <script>
        
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const grid = new Grid(9,9);
        const gridHighlights = new Grid(8,8);
        const gridNav = new Grid(8,8);
        

        gridHighlights.loop((x,y,v) => {
            gridHighlights.set(x,y,'rgba(0,0,0,0.0)');    
        });

        let selected;
        let actors = [];
        const player = new BasePawn();

        const imgs = {};

        const tileSize = 32*3;
        const pieceSize = 64;

        imgs.bunny = loadImage('i/bunny.png');
        imgs.skull = loadImage('i/skull.png');
        imgs.rock = loadImage('i/rock.png');
        imgs.brick = loadImage('i/brick.png');
        imgs.orc = loadImage('i/orc.png');
        imgs.wolf = loadImage('i/wolf.png');
        imgs.golem = loadImage('i/golem.png');
        imgs.shadow = loadImage('i/shadow.png');
        imgs.zombie = loadImage('i/zombie.png');

        imgs.move = loadImage('i/move.png');
        imgs.target = loadImage('i/target.png');

        imgs.skeletonArcher = loadImage('i/skeleton_archer.png');
        imgs.skeletonWarrior = loadImage('i/skull.png');
        

        function loadImage(src){
            const img = new Image();
            img.src = src;
            return img;
        }

        const icon_lut = {
            '🪨':imgs.rock,
            'P':imgs.bunny,
            'O':imgs.orc,
            'W':imgs.wolf,
            "G":imgs.golem,
            "SW":imgs.skeletonWarrior,
            "SA":imgs.skeletonArcher,
            "Z":imgs.zombie
        };

        const inventory = document.createElement('textarea');
        document.body.appendChild(inventory);
        inventory.className = 'inventory noprint';

        inventory.addEventListener('keyup',function(){
            localStorage.inventory = inventory.value;
        },false);

        inventory.value = localStorage.inventory || '';

        let hp = 10;
        let maxHP = 10;
        const hpDisplay = document.createElement('canvas');
        hpDisplay.width = 300;
        hpDisplay.height = 37;
        const hpContainer = document.createElement('div');

        hpContainer.className = 'hpContainer';

        const hpUp = document.createElement('button');
        hpUp.textContent = '>'
        hpUp.addEventListener('mousedown',function(){
            hp += 1;
            if(hp > maxHP){
                hp = maxHP;
            }
            updateHPDisplay();
        })

        const hpDown = document.createElement('button');
        hpDown.textContent = '<'
        hpDown.addEventListener('mousedown',function(){
            hp -= 1;
            if(hp < 0){
                hp = 0;
            }
            updateHPDisplay();
        })


        const maxHPUp = document.createElement('button');
        maxHPUp.textContent = '>>'
        maxHPUp.addEventListener('mousedown',function(){
            maxHP += 1;
            hp += 1;
            updateHPDisplay();
        })

        const maxHPDown = document.createElement('button');
        maxHPDown.textContent = '<<'
        maxHPDown.addEventListener('mousedown',function(){
            maxHP -= 1;
            if(maxHP < 1){
                maxHP = 1;
            }
            if(maxHP < hp){
                hp = maxHP;
            }
            updateHPDisplay();
        })

        hpContainer.appendChild(maxHPDown)        
        hpContainer.appendChild(hpDown)        
        hpContainer.appendChild(hpDisplay);
        hpContainer.appendChild(hpUp)        
        hpContainer.appendChild(maxHPUp)      
        
        updateHPDisplay();

        const gold = document.createElement('input');
        gold.className = 'gold';
        gold.placeholder = "Gold";

        gold.addEventListener('focus',function(){
            gold.value = gold.value.split('gold').join('').trim()
            gold.select();
        },false);

        gold.addEventListener('blur',function(){
            gold.value = gold.value.trim() + ' gold';
            localStorage.gold = gold.value;
        },false);

        gold.value = localStorage.gold || "0 gold";

        function updateHPDisplay(){
            const ctx = hpDisplay.getContext('2d');
            ctx.clearRect(0,0,hpDisplay.width,hpDisplay.height);
            const step = hpDisplay.width/maxHP;
            ctx.strokeStyle = ctx.fillStyle = 'hsl(0,50%,50%)'
            ctx.lineWidth = 2;
            ctx.save();
            for(let i = 0; i < maxHP; i++){
                ctx.strokeRect(step*i,0,step,hpDisplay.height);
            }
            for(let i = 0; i < hp; i++){
                ctx.fillRect(step*i+4,4,step-8,hpDisplay.height-8);
            }
            ctx.restore();
        }

        function note(a){
            log.value += a+'\n';
            log.scrollTop = log.scrollHeight;
        }

        const tileOptions = "🐻🪨🎁🦇🕷️🦂";

        let wave = 0;
        let area = 'Forest';
        
        const display = document.createElement('p');

        updateDisplay();
        
        function rand(n){
            return Math.floor(Math.random() * n);
        }

        function d4(){
            return rand(4);
        }

        function d6(){
            return rand(6);
        }

        function d8(){
            return rand(8);
        }

        function d12(){
            return rand(12);
        }

        function d20(){
            return rand(20);
        }

        const monsterRoll = document.createElement('button');
        optionsContainer.appendChild(monsterRoll);

        optionsContainer.appendChild(hpContainer);

        optionsContainer.appendChild(gold);
        monsterRoll.textContent = 'Next Turn';
        
        const page = document.createElement('div');
        page.className = 'page noprint';
        document.body.appendChild(page);

        page.appendChild(display);

        const monsterRollOut = document.createElement('p');
        page.appendChild(monsterRollOut);
        
        mouse = {
            x:0,
            y:0,
            gx:0,
            gy:0
        }

        const log = document.createElement('textarea');
        log.className = 'log';
        log.setAttribute('readonly',true);

        function renderInventory(){

            const page = document.createElement('page');
            page.className = 'page';
            document.body.appendChild(page);

            function elem(n){
                const e = document.createElement(n);
                page.appendChild(e);
                return e;
            }

            page.appendChild(tableify(items.equipment,'Equipment'))
            page.appendChild(tableify(items.items,'Item'))

            const page2 = document.createElement('page');
            page2.className = 'page';
            document.body.appendChild(page2);

            const columns = ['armor','move','attack','int','cost','roll'];
            page2.appendChild(tableify(monsters.Forest,'Area 1 - Forest',columns,'monsterList'));
            page2.appendChild(tableify(monsters.Caves,'Area 2 - Caves',columns,'monsterList'));
            page2.appendChild(tableify(monsters.Village,'Area 3 - Village',columns,'monsterList'));

            const page3 = document.createElement('page');
            page3.className = 'page';
            document.body.appendChild(page3);
            page3.appendChild(tableify(items.Abilities,'Ability'));
        }

        Array.prototype.push_unique = function(n){
            if(!this.includes(n)){
                this.push(n);
            }
        }

        function tableify(obj,title,columns=[],className=''){
            if(columns.length === 0){
                for(let key in obj){
                    for(let sub in obj[key]){
                        columns.push_unique(sub);
                    }
                }
            }

            const table = document.createElement('table');
            
            const tr = document.createElement('tr');
            table.appendChild(tr);

            const td = document.createElement('td');
            td.textContent = title;
            tr.appendChild(td);

            for(let item of columns){
                const td = document.createElement('td');
                td.textContent = item;
                tr.appendChild(td);
            }

            for(let key in obj){
                const tr = document.createElement('tr');
                table.appendChild(tr);

                const td = document.createElement('td');
                td.textContent = key;
                tr.appendChild(td);

                for(let item of columns){
                    const td = document.createElement('td');
                    td.textContent = obj[key][item] || '';
                    tr.appendChild(td);
                }

            }

            table.className = className;

            return table;

        }


        function updateDisplay(){
            display.textContent = `${area} - Wave: ${wave}`;
        }

        const items = {
            equipment:{
                Sword:{
                    stats:"D6",
                    special:"",
                    cost:30,
                    sell:15
                },
                Dagger:{
                    stats:"D4",
                    special:"Move +1",
                    cost:16,
                    sell:8
                },
                Bow:{
                    stats:"D6, Range 3",
                    special:"Uses arrows, can retrieve, comes with 3 arrows",
                    cost:40,
                    sell:20
                },
                Shield:{
                    stats:"Armor +2",
                    special:"Counter: if 1H in other hand, D4>2, Attack Attacker",
                    cost:30,
                    sell:15
                },
                Spear:{
                    stats:"D6, Range 2, Pierce",
                    special:"Throw: Range 3, can retrieve, Damage +2",
                    cost:24,
                    sell:12
                },
                Whip:{
                    stats:"D8, Range 2",
                    special:"Will Damage +2",
                    cost:40,
                    sell:20
                },
                Great_Sword:{
                    stats:"D12, Knockback +1",
                    special:"Move -1",
                    cost:80,
                    sell:40
                },
                Wand:{
                    stats:"D4 / 2",
                    special:"Spell Damage + 2, Catalyst",
                    cost:90,
                    sell:45
                },
                Staff:{
                    stats:"D4",
                    special:"Spell Damage + 4, Catalyst, 2 Hand	",
                    cost:90,
                    sell:45
                },
                Great_Shield:{
                    stats:"Armor +3",
                    special:"Move -1",
                    cost:80,
                    sell:40
                },
                Axe:{
                    stats:"D8",
                    special:"",
                    cost:30,
                    sell:15
                },
                Great_Axe:{
                    stats:"D20, Knockback +1",
                    special:"Move -2, Two Handed",
                    cost:0,
                    sell:0
                },
                Scythe:{
                    stats:"D8, Pierce",
                    special:"3 Targets in row, Two Handed, Catalyst",
                    cost:60,
                    sell:30
                },
                Hammer:{
                    stats:"D12, Knockback +3",
                    special:"Move -1",
                    cost:50,
                    sell:25
                },
                Crossbow:{
                    stats:"D12, Range 4",
                    special:"uses bolts, can retrieve, comes with 3 bolts",
                    cost:80,
                    sell:40
                },
                Bolt_Action_Rifle:{
                    stats:"D20, Range 8",
                    special:"consumes 1 bullet, must reload after shot (consumes turn)",
                    cost:120,
                    sell:60
                },
                Revolver:{
                    stats:"D12, Range 4",
                    special:"consumes 1 bullet, must reload after 6 shots (consumes turn)",
                    cost:140,
                    sell:70
                },
                Claws:{
                    stats:"2D6",
                    special:"Move +1",
                    cost:40,
                    sell:20
                },
                Grimoire:{
                    stats:"D4 / 2",
                    special:"Spell Damage +2, has 2 random spells on pickup, Catalyst",
                    cost:-1,
                    sell:300
                },
                Iron_Gauntlets:{
                    stats:"2D4",
                    special:"Move +1, Grab Ability: D6 > target move - target weight, throw to any nearby tile",
                    cost:40,
                    sell:20
                }
            },
            items:{
                Health_Potion:{
                    type:"Consumable",
                    effect:"Heal +5",
                    cost:5,
                    sell:5
                },
                Arrow_x_3:{
                    type:"Ammo",
                    effect:"Reusable, Enchantable",
                    cost:5,
                    sell:2
                },
                Bullet_x_3:{
                    type:"Ammo",
                    effect:"Not Enchantable",
                    cost:5,
                    sell:2
                },
                Poison:{
                    type:"Consumable",
                    effect:"Apply to Sharp Weapon / Arrow / Bait, +2 Damage on targets with flesh for next 3 turns"
                },
                Bait:{
                    type:"Consumable",
                    effect:"Lure enemy to location, works with traps and poison",
                    cost:5,
                    sell:2.5
                },
                Anchor_Trap:{
                    type:"Trap",
                    effect:"D4 > 1 Enemy is trapped for 2 turns, explodes when stepping off",
                    cost:10,
                    sell:5
                },
                Bomb_Trap:{
                    type:"Trap",
                    effect:"D8 to tile and nearby surrounding tiles, explodes when stepping off",
                    cost:20,
                    sell:10
                },
                Sleep_Trap:{
                    type:"Trap",
                    effect:"D4 > 1 puts living enemies to sleep, explodes when stepping off",
                    cost:10,
                    sell:5
                },
                Whiskey:{
                    type:"Consumable",
                    effect:"increase max health by 5 for 3 turns, -1 to dodge rolls",
                    cost:15,
                    sell:10
                },
                Gas_Mask:{
                    type:"Equipable (Head)",
                    effect:"grants resistance to Sleep trap, Gas and Smells",
                    cost:30,
                    sell:15
                },
                Basic_Armor:{
                    type:"Equipable (Body)",
                    effect:"Armor +1",
                    cost:50,
                    sell:25
                },
                Full_Plate_Armor:{
                    type:"Equipable (Body)",
                    effect:"Armor +2, Move -1",
                    cost:80,
                    sell:40
                }
            },
            Abilities:{
                Fireball:{
                    cooldown:1,
                    ability:"D6 R3, Fire Damage, hits all nearby squares"
                },
                Raise_Dead:{
                    cooldown:2,
                    ability:"Corpse + D4 > 1, raise Controllable Zombie"
                },
                Chilling_Touch:{
                    cooldown:1,
                    ability:"Target has half movement speed for 2 turns"
                },
                Draining_Kiss:{
                    cooldown:1,
                    ability:"D6, caster gains damage as health; if target tranced, target loses next turn"
                },
                Trance:{
                    cooldown:2,
                    ability:"R2 target involuntarily moves towards caster for 2 turns and cannot attack caster, ends early if target is hurt"
                },
                Howl:{
                    cooldown:2,
                    ability:"R2 Allies gain +2 Damage for 1 turn"
                },
                Blink:{
                    cooldown:3,
                    ability:"teleport R5, if D4 > 3 can go through walls, otherwise end at wall"
                },
                Blessing:{
                    cooldown:3,
                    ability:"R3 Heal target for D6, if target doesn't have health, give 1 hp barrier"
                },
                Twist_Stone:{
                    cooldown:3,
                    ability:"Create Stone or Remove Stone"
                },
                Reflect:{
                    cooldown:3,
                    ability:"R2 Reflect next damage taken on attacker, up to R2"
                },
                Shift_Position:{
                    cooldown:3,
                    ability:"D4 > 1; exchange places with target, R4"
                },
                Pushing_Gale:{
                    cooldown:2,
                    ability:"R2 throw target up to R4 away from caster (as far as possible)"
                },
                Pulling_Gale:{
                    cooldown:2,
                    ability:"R4 pull target to caster"
                },
                Resurrect:{
                    cooldown:1,
                    ability:"Raise dead Ally to 50% health, drains casters health to 1"
                },
                Raise_Shadow:{
                    cooldown:2,
                    ability:"Create controllable Shadow Creature, caster loses 5 hp"
                },
                Double_Time:{
                    cooldown:2,
                    ability:"target gets 2 turns this round, back to back or additional turn after caster if already completed turn"
                },
                Mana_Bomb:{
                    cooldown:2,
                    ability:"R2 place large bomb, explodes in 2 turns for D12 damage to tile and surrounding tiles"
                },
                Blood_Bow:{
                    cooldown:1,
                    ability:"R6, D6, caster loses 1hp "
                },
                Anchor:{
                    cooldown:2,
                    ability:"target cannot move for 1 turn"
                },
                Gel:{
                    cooldown:3,
                    ability:"target loses next turn"
                }
            }
        }

        const monsters = {
            Forest:{
                Zombie:{
                    image:imgs.zombie,
                    move:1,
                    armor:3,
                    int:"Dumb",
                    attack:"D4",
                    cost:1
                },
                Wolf:{
                    image:imgs.wolf,
                    move:3,
                    armor:2,
                    int:"Dumb",
                    attack:"D6",
                    cost:3
                },
                Orc:{
                    image:imgs.orc,
                    move:2,
                    armor:3,
                    int:"Mid",
                    attack:"D6",
                    cost:3
                },
                Golem:{
                    image:imgs.golem,
                    move:1,
                    armor:4,
                    int:"Dumb",
                    attack:"D12",
                    cost:3
                },
                Skeleton_Warrior:{
                    image:imgs.skeletonWarrior,
                    move:2,
                    armor:2,
                    int:"Dumb",
                    attack:"D4",
                    cost:2
                },
                Skeleton_Archer:{
                    image:imgs.skeletonArcher,
                    move:2,
                    armor:2,
                    int:"Smart",
                    attack:"D6 R3",
                    cost:3
                }
            },
            Caves:{
                Slime:{
                    move:2,
                    armor:4,
                    int:"Dumb",
                    attack:"D4",
                    cost:1
                },
                Bat:{
                    move:4,
                    armor:1,
                    int:"Dumb",
                    attack:"D6",
                    cost:2
                },
                Goblin_Archer:{
                    move:2,
                    armor:2,
                    int:"Dumb",
                    attack:"D6 R3",
                    cost:1
                },
                Necromancer:{
                    move:2,
                    armor:4,
                    int:"Smart",
                    attack:"Raise Undead; Vampiric Touch; D4",
                    cost:4
                },
                Werewolf:{
                    move:4,
                    armor:4,
                    int:"Dumb",
                    attack:"D8",
                    cost:5
                },
                Goblin_Medic:{
                    move:3,
                    armor:2,
                    int:"Smart",
                    attack:"Healing Touch; D6",
                    cost:3
                }
            },
            Village:{
                Enchanted_Wolf:{
                    move:3,
                    armor:3,
                    int:"Dumb",
                    attack:"D8; Howl",
                    cost:2
                },
                Enchanted_Bat:{
                    move:4,
                    armor:2,
                    int:"Dumb",
                    attack:"D8",
                    cost:0
                },
                Enslaved_Villager:{
                    move:2,
                    armor:2,
                    int:"Dumb",
                    attack:"D6 R2 Pierce",
                    cost:1
                },
                Enslaved_Soldier:{
                    move:2,
                    armor:4,
                    int:"Smart",
                    attack:"D8; can dodge",
                    cost:3
                },
                Enslaved_Archer:{
                    move:3,
                    armor:4,
                    int:"Smart",
                    attack:"D6 R3",
                    cost:3
                },
                Minor_Succubus:{
                    move:3,
                    hp:6,
                    armor:4,
                    int:"Smart",
                    attack:"Draining Kiss, Trance, D6; can dodge",
                    cost:3
                }
            }
        }

        for(let key in monsters){
            let i = 1;
            for(let entry in monsters[key]){
                monsters[key][entry].hp = monsters[key][entry].hp || 1; 
                monsters[key][entry].roll = i;
                i += 1;
            }
        }

        for(let key in items){
            let i = 1;
            for(let item in items[key]){
                items[key][item].roll = i;
                i+= 1;
            }
        }

        //renderInventory();
    
        function monsterStats(monster){
            monster = monster.replace(' ','_');
            for(let key in monsters){
                if(monsters[key][monster]){
                    const data = monsters[key][monster];
                    return `<h3>${monster.replace('_',' ')}</h3> Armor ${data.armor},  Move ${data.move}, Attack ${data.attack}, ${data.int}`;
                }
            }
        }

        function getMonster(monster){
            monster = monster.replace(' ','_');
            for(let key in monsters){
                if(monsters[key][monster]){
                    return monsters[key][monster];
                }
            }
        }

        monsterRoll.addEventListener('mousedown',nextTurn,false);
        nextWave();

        rollButton('D4',d4);
        rollButton('D6',d6);
        rollButton('D12',d12);
        rollButton("D20",d20);

        optionsContainer.appendChild(document.createElement('br'));
        /*
        for(let area in monsters){
            for(let monster in monsters[area]){
                const button = document.createElement('button');
                button.textContent = monster.split('_').join(' ');
                button.addEventListener('mousedown',function(){
                    spawnMonster(monster);
                });
                monsterButtonList.appendChild(button);
            }
        }
        */

        function rollButton(text,func,parent=optionsContainer){
            const button = document.createElement('button');
            button.textContent = text;
            button.addEventListener('mousedown',function(){
                note("Rolled a "+text+": "+(func()+1))
            });
           parent.appendChild(button);
        }

        setupGame(page);
        page.appendChild(log);

        function Action(){
            this.icon = '';
            this.render = function(ctx){

            }
            this.description = '';
            this.callback = function(self,target,x,y){

            }
        }

        function ActionMove(){
            this.icon = imgs.move;
            this.description = 'move to location';
            this.callback = function(self,target,x,y){
                self.x = x;
                self.y = y;
            }   
        }

        function ActionPush(){

        }

        function BasePawn(){
            this.name = '';
            this.health = 10;
            this.armor = 0;
            this.movementSpeed = 0;
            this.attackCount = 1;
            this.position = vec2(0,0);
            this.attackDice = 0;
            this.attacked = 0;
            this.moved = 0;
            this.attackRange = 0;
            this.iq = 0;
            this.actions = {
                move:ActionMove,
                push:ActionPush
            };
            this.navCloser = function(){
                let lowest = Infinity;
                let dir = vec2(0,0);
                for(let d of V2.cardinal){
                    const n = gridNav.get(this.position.x+d.x,this.position.y+d.y,Infinity);
                    console.log(n,lowest,d);
                    if(n < lowest){
                        lowest = n;
                        dir = d;
                    }
                }
                this.moveDirection(dir)
            }
            this.moveDirection = function(dir){
                this.move(
                    this.position.x+dir.x,
                    this.position.y+dir.y
                );
            }
            this.remove = function(){
                grid.set(this.position.x,this.position.y,0);
                const i = actors.indexOf(this);
                actors.splice(i,1);
                note(this.name + ' died');
            };
            this.hurt = function(attacker,damage){
                damage -= this.armor;
                if(damage <= 0){
                    note(attacker.name +"'s attack bounces off!");
                }else{
                    note(this.name+" takes " + damage +" damage!");
                    this.health -= damage;
                    if(this.health <= 0){
                        note(this.name + " died");
                    }
                }
            };
            this.attemptAttack = function(target){
                
                if(!target.hurt){
                    return;
                }

                if(this.attackCount - this.attacked <= 0){
                    return;
                }

                this.attacked += 1;
                target.hurt(this,Math.floor(Math.random()*this.attackDice));

            }
            this.move = function(x,y){

                if(grid.get(x,y)){
                    return;
                }

                var dis = Math.max(Math.abs(x-this.position.x), Math.abs(y-this.position.y));
                
                if(dis > this.movementSpeed-this.moved){
                    return;
                }

                grid.set(this.position.x,this.position.y,0);
                grid.set(x,y,this);
                this.moved += dis;
                this.position.x = x;
                this.position.y = y;
            }
            actors.push(this);
        }


        function setupGame(container){
            
            let current_tile = '';

            const w = tileSize*8;
            const h = tileSize*8;
            canvas.width = w;
            canvas.height = h;
            canvas.className = 'board';
            container.appendChild(canvas);


            for(let i = 0; i < 9; i++){
                
                const x = rand(8);
                const y = rand(8);

                grid.set(x,y,'🪨')

            }

            const a = d4();
            const b = d4();
            const c = d4();

            player.health = player.maxHealth = 10;
            player.movementSpeed = 3;
            player.attackDice = 6;
            player.attackRange = 1;
            player.position = grid.quadraticToGrid(a,b,c);
            player.image = imgs.bunny;
            grid.quadraticSet(a,b,c,player);

            render();

        }

        function render(){
            ctx.font = '40px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = "middle";
            ctx.imageSmoothingEnabled = false;
            const s = tileSize;
            const hs = s * 0.5;
            ctx.fillStyle = 'rgba(0,0,0,0.1)'
            ctx.lineWidth = 1;
            ctx.strokeRect(mouse.gx*s+10,mouse.gy*s+10,s-20,s-20);
            ctx.fillStyle = '#000';
            ctx.lineWidth = 1;
            
            grid.loop((x,y,v) => {
                ctx.drawImage(imgs.brick,0,0,16,16,x*s,y*s,s,s);
            });

            const hps = pieceSize * 0.5;

            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 5;
            grid.loop((x,y,v) => {
                if(v){
                    if(icon_lut[v]){
                        ctx.globalAlpha = 0.2;
                        ctx.drawImage(imgs.shadow,0,0,16,16,x*s+hs-hps,y*s+hs-hps+8,pieceSize,pieceSize);
                        ctx.globalAlpha = 1.0;
                        ctx.drawImage(icon_lut[v],0,0,16,16,x*s+hs-hps,y*s+hs-hps,pieceSize,pieceSize);
                    }else if(v.image){
                        let movesLeft = v.movementSpeed - v.moved;
                        let attacksLeft = v.attackCount-v.attacked;
                        if(movesLeft + attacksLeft === 0){
                            ctx.globalAlpha = 0.5;
                        }
                        const px = x*s+hs-hps;
                        const py = y*s+hs-hps;
                        ctx.drawImage(v.image,0,0,16,16,px,py,pieceSize,pieceSize);
                        ctx.fillStyle = 'green';
                        ctx.strokeText(movesLeft,px,py-hps*0.33);
                        ctx.fillText(movesLeft,px,py-hps*0.33);
                        ctx.fillStyle = 'red';
                        ctx.strokeText(attacksLeft,px+pieceSize,py-hps*0.33);
                        ctx.fillText(attacksLeft,px+pieceSize,py-hps*0.33);
                        ctx.globalAlpha = 1.0;
                    }else{
                        ctx.fillText(v,x*s+hs,y*s+hs);
                    }
                }
            });

            gridHighlights.loop((x,y,v) => {
                if(v === 1){
                    ctx.drawImage(imgs.move,0,0,16,16,x*s+hs*0.5,y*s+hs*0.5,hs,hs);
                }else if(v === 2){
                    ctx.drawImage(imgs.target,0,0,16,16,x*s+hs*0.5,y*s+hs*0.5,hs,hs); 
                }
            });

            gridNav.loop((x,y,v) => {
                const px = x*s+hs;
                const py = y*s+hs;
                ctx.fillText(v,px,py);
            });

            if(selected){
                ctx.globalAlpha = 0.5;
                const ps = pieceSize * 0.75;
                const x = mouse.gx;
                const y = mouse.gy;
                if(icon_lut[selected]){
                    ctx.drawImage(icon_lut[selected],0,0,16,16,x*s+ps*0.5,y*s+ps*0.5,ps,ps);
                }else if(selected.image){
                    ctx.drawImage(selected.image,0,0,16,16,x*s+hs-hps,y*s+hs-hps,pieceSize,pieceSize);
                }else{
                    ctx.fillText(initials(selected.name),x*s+hs,y*s+hs);
                }
                ctx.globalAlpha = 1.0;
            }

        }

        function Grid(w,h){
            const data = [];
            this.data = data;
            console.log({w,h});
            for(let i = 0; i < w * h; i++){
                data.push(0);
            }
            this.get = function(x,y,v,def=-1){
                const id = x + y * w;
                if(id > data.length-1 || id < 0){
                    return def;
                }
                return data[id];

            }
            this.set = function(x,y,v){
                const id = x + y * w;
                if(id > data.length-1 || id < 0){
                    return false
                }
                data[id] = v;
                return true;
            };


            this.navFill = function(x,y,isSolid){

                this.loop((x,y) => {
                    this.set(x,y,99);
                })

                let visited = {};
                let frontlines = [];

                function push(x,y,dis){
                    const id = (x + y * w).toString();
                    if(!visited[id] && !isSolid(x,y)){
                        visited[id] = true;
                        frontlines.push([x,y,dis+1]);
                    }
                }

                push(x+1,y,0);
                push(x-1,y,0);
                push(x,y+1,0);
                push(x,y-1,0);

                /*
                push(x+1,y+1,0);
                push(x-1,y-1,0);
                push(x-1,y+1,0);
                push(x+1,y-1,0);
                */
                while(frontlines.length>0){
                    var next = frontlines.shift();
                    push(next[0]+1,next[1],next[2]);
                    push(next[0]-1,next[1],next[2]);
                    push(next[0],next[1]+1,next[2]);
                    push(next[0],next[1]-1,next[2]);
                    /*
                    push(next[0]+1,next[1]+1,next[2]);
                    push(next[0]-1,next[1]-1,next[2]);
                    push(next[0]-1,next[1]+1,next[2]);
                    push(next[0]+1,next[1]-1,next[2]);
                    */
                    this.set(next[0],next[1],next[2]);
                }
                this.set(x,y,0);
            };

            this.floodFill = function(x,y,v,isSolid,r=1){
                let visited = {};
                let frontlines = [];
                
                if(r <= 0){
                    return;
                }

                function push(x,y,dis){
                    if(dis >= r){
                        return;
                    } 
                    const id = (x + y * w).toString();
                    if(!visited[id] && !isSolid(x,y)){
                        visited[id] = true;
                        frontlines.push([x,y,dis+1]);
                    }
                }

                push(x+1,y,0);
                push(x-1,y,0);
                push(x,y+1,0);
                push(x,y-1,0);

                /*
                push(x+1,y+1,0);
                push(x-1,y-1,0);
                push(x-1,y+1,0);
                push(x+1,y-1,0);
                */
                while(frontlines.length>0){
                    var next = frontlines.shift();
                    push(next[0]+1,next[1],next[2]);
                    push(next[0]-1,next[1],next[2]);
                    push(next[0],next[1]+1,next[2]);
                    push(next[0],next[1]-1,next[2]);
                    /*
                    push(next[0]+1,next[1]+1,next[2]);
                    push(next[0]-1,next[1]-1,next[2]);
                    push(next[0]-1,next[1]+1,next[2]);
                    push(next[0]+1,next[1]-1,next[2]);
                    */
                    this.set(next[0],next[1],v);
                }
            };

            this.loop =function(callback){
                for(let x = 0; x < w; x++){
                    for(let y = 0; y < h; y++){
                        callback(x,y,data[x+y*w]);
                    }
                }
            }
            this.quadraticToGrid = function(a,b,c){
                let x = 0;
                let y = 0;
                let lut = [
                    [1,0],
                    [1,1],
                    [0,1],
                    [0,0]
                ];
                const aa = lut[a];
                const bb = lut[b];
                const cc = lut[c];

                x += aa[0] * 4;
                y += aa[1] * 4;

                x += bb[0] * 2;
                y += bb[1] * 2;
                
                x += cc[0];
                y += cc[1];
                return vec2(x,y);
            }
            this.quadraticSet = function(a,b,c,v){
                let x = 0;
                let y = 0;
                let lut = [
                    [1,0],
                    [1,1],
                    [0,1],
                    [0,0]
                ];
                const aa = lut[a];
                const bb = lut[b];
                const cc = lut[c];

                x += aa[0] * 4;
                y += aa[1] * 4;

                x += bb[0] * 2;
                y += bb[1] * 2;
                
                x += cc[0];
                y += cc[1];
                const id = x + y * w;
                if(id > data.length-1 || id < 0){
                    return false
                }
                data[id] = v;
                return true;
            }

            this.quadraticGet = function(a,b,c,v){
                let x = 0;
                let y = 0;
                let lut = [
                    [1,0],
                    [1,1],
                    [0,1],
                    [0,0]
                ];
                const aa = lut[a];
                const bb = lut[b];
                const cc = lut[c];

                x += aa[0] * 4;
                y += aa[1] * 4;

                x += bb[0] * 2;
                y += bb[1] * 2;
                
                x += cc[0];
                y += cc[1];
                const id = x + y * w;
                if(id > data.length-1 || id < 0){
                    return undefined;
                }
                console.log(data[id]);
                return data[id];
            }
        }

        function loop(){
            requestAnimationFrame(loop);
            render();
        }

        loop();

        function counter(n,callback){
            const span = document.createElement('span');
            span.className = 'counter';
            
            const out = document.createElement('span');
            
            const lower =document.createElement('button');
            lower.addEventListener('mousedown',function(){
                n -= 1
                out.textContent = n;
                callback(n);
            });
            lower.textContent = '<';
            
            const higher =document.createElement('button');
            higher.addEventListener('mousedown',function(){
                n += 1
                out.textContent = n;
                callback(n);
            });
            higher.textContent = '>';

            out.textContent = n;
            span.appendChild(lower);
            span.appendChild(out);
            span.appendChild(higher);
            return span;    
        }

        function getQuadraticPlayerPosition(){
            let pos;
            grid.loop(function(x,y,v){
                if(v === 'P'){

                }
            })
        }

        function nextTurn(){

            let cursor = 0;
            let delay = 250;

            gridNav.navFill(player.position.x,player.position.y,isSolidOccupied);
            
            function next(){
                if(actors[cursor]){
                    
                    const a = actors[cursor];
                    if(a.iq > 0){
                        if(a.movementSpeed - a.moved <= 0){
                            cursor += 1;
                            setTimeout(next,delay);
                            return;
                        }else{
                            a.navCloser();
                            gridNav.navFill(player.position.x,player.position.y,isSolidOccupied);
                            setTimeout(next,delay);
                        }
                    }else{
                        cursor += 1;
                        next();
                    }
                }else{
                    for(let actor of actors){
                        actor.moved = 0;
                        actor.attacked = 0;
                    }
                }
            }

            next();

        }

        function nextWave(){
            wave += 1
            if(wave > 10){
                wave = 1;
                if(area === 'Forest'){
                    area = 'Caves';
                }else if(area === 'Caves'){
                    area = "Village";
                }
            }

            const areas = {
                Forest:Object.keys(monsters.Forest),
                Caves:Object.keys(monsters.Caves),
                Village:Object.keys(monsters.Village),
            }

            monsterRollOut.innerHTML = '<hr/>';

            if(wave % 5 === 0){
                monsterRollOut.innerHTML += '<h3>Traveling Merchant</h3> Anything of interest? <br/><br/>';

                for(let i = 0; i < 4; i++){
                    const d = d4();
                    if(d === 0 || d === 1){
                        let keys = Object.keys(items.items);
                        const key = keys[Math.floor(Math.random()*keys.length)]
                        const item = items.items[key];
                        monsterRollOut.innerHTML += `<b>${key}</b> ${item.type}, ${item.effect} - ${item.cost} / ${item.sell}<br/>`;
                    }else{
                        let keys = Object.keys(items.equipment);
                        const key = keys[Math.floor(Math.random()*keys.length)]
                        const item = items.equipment[key];
                        monsterRollOut.innerHTML += `<b>${key}</b> ${item.stats}, ${item.special} - ${item.cost} / ${item.sell}<br/>`;
                    }
                }

                monsterRollOut.innerHTML += "<hr/>";
            }
            let first = true;
            let cc = wave;
            let monsterCount = 1;
            var qPlayerPos = getQuadraticPlayerPosition();
            while(cc >= 0){
                let next = areas[area][d6()];
                const monster = getMonster(next);
                if(cc - monster.cost >= 0  || first){

                    first = false;
                    spawnMonster(next);
                    monsterCount += 1;
                }
                cc -= monster.cost;
            }

            updateDisplay();
            render();
        }

        function spawnMonster(next){
            let a = d4();
            let b = d4();
            let c = d4();
            let l = 0;

            while(grid.quadraticGet(a,b,c) !== undefined && l < 100){
                a = d4();
                b = d4();
                c = d4();
                l++;
            }

            let position = [a+1,b+1,c+1];
            const monsterInfo = document.createElement('span');
            monsterInfo.innerHTML = `${monsterStats(next)} <br/> Position ${position[0]},${position[1]},${position[2]}`;
            monsterInfo.className = 'monsterInfo';
            monsterRollOut.appendChild(monsterInfo);
            const monster = getMonster(next);
            const gp = grid.quadraticToGrid(a,b,c);
            console.log(monster);

            const actor = new BasePawn()
            actor.image = monster.image;
            actor.health = monster.hp;
            actor.maxHealth = monster.hp;
            actor.armor = monster.armor;
            actor.iq = ({Dumb:1,mid:2,Smart:3})[monster.int]; //this is a cursed line of code lol
            actor.attackDice = parseInt(monster.attack.split(' ').shift(),10);
            actor.attackRange = parseInt(monster.attack.split(' ').pop(),10);
            actor.position = gp;
            actor.movementSpeed = monster.move;
            grid.set(gp.x,gp.y,actor);

            render();

        }

        function initials(name){
            const words = name.split(' ').join('_').split('_');
            console.log( words.map(a => a[0]).join(''))
            return words.map(a => a[0]).join('');
        }

        canvas.addEventListener('mousemove',function(e){
            ctx.fillStyle = '#000';
            var rect = canvas.getBoundingClientRect();
            
            ctx.clearRect(0,0,canvas.width,canvas.height);
            
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            
            mouse.x = x;
            mouse.y = y;
            
            const gx = Math.floor(x/100);
            const gy = Math.floor(y/100);
            
            mouse.gx = gx;
            mouse.gy = gy;
            
            render();

        })

        canvas.addEventListener('mousedown',function(e){
            var rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const gx = Math.floor(x/100);
            const gy = Math.floor(y/100);
            if(selected){
                const target = grid.get(gx,gy);
                if(target){
                    if(target == selected){
                        selected = false;
                        gridHighlights.loop((x,y,v) => {
                            gridHighlights.set(x,y,false);
                        });
                        if(selected.attackCount - selected.attacked > 0){
                            gridHighlights.floodFill(gx,gy,2,function(x,y){
                                if(x < 0 || x > 7) return true;
                                if(y < 0 || y > 7) return true;
                                return false;
                            },selected.attackRange);
                        }
                        return;
                    }
                    selected.attemptAttack(target);
                    return;
                }
                selected.move(gx,gy);
                gridHighlights.loop((x,y,v) => {
                    gridHighlights.set(x,y,false);
                });
                gridHighlights.floodFill(gx,gy,2,function(x,y){
                    if(x < 0 || x > 7) return true;
                    if(y < 0 || y > 7) return true;
                    return false;
                },selected.attackRange);
                selected = false;
            }else{
                selected = grid.get(gx,gy);
                if(!selected){
                    gridHighlights.loop((x,y,v) => {
                        gridHighlights.set(x,y,false);
                    });
                    return;
                }
                if(!selected.move){
                    selected = false;
                    return;
                }
                gridHighlights.loop((x,y,v) => {
                    gridHighlights.set(x,y,false);
                });
                if(selected){
                    gridHighlights.floodFill(gx,gy,1,isSolidOccupied,selected.movementSpeed-selected.moved);
                }

            }
        })

        function isSolidOccupied(x,y){
            if(x < 0 || x > 7) return true;
            if(y < 0 || y > 7) return true;
            if(grid.get(x,y)) return true;
            return false;
        }

    </script>
</body>
</html>