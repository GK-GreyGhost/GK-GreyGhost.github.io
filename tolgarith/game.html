<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Labyrinth of Tolgarith</title>
    <style>
        *{
            box-sizing: border-box;
            margin:auto;
            position:relative;
            font-family: monospace;
        }


        html,body{
            margin:0px;
            width:100%;
            height:100%;
            overflow:hidden;
        }

        p, div{
            line-height: 1.5em;
        }

        canvas{
            image-rendering: pixelated;
            position:fixed;
            top:0px;
            left:0px;
            right:0px;
            bottom:0px;
            margin:auto;
        }

        button{
            margin:5px;
            padding:10px;
            border:none;
            background:#000;
            color:#fff;
        }
        
        p{
            margin:25px;
        }

        body{
            text-align:left;
            background:#000;
        }

        hr{
            margin:20px 0px;
            border:none;
            border-bottom:solid 1px #000;
        }

        h1{
            margin:10px 0px;
            position:fixed;
            bottom:10px;
            right:25px;
            opacity:0.25;
        }

        tr,td,table{
            border:solid 1px #000;
            border-collapse: collapse;
        }

        table{
            margin:10px;
        }

        td{
            padding:5px;

        }

        .page{
            padding:10px;
            margin:10px;
            display:block;
            width:calc(100% - 20px);
            min-height:90%;
            border:solid 1px #000;
        }

        .hpContainer{
            display:flex;
            width:fit-content;
        }

        .hpContainer button{
            background:hsl(0,50%,50%);
        }

        #optionsContainer{
            display:flex;
            margin:10px;
            text-align:left;
            width:fit-content;
        }

        .gold{
            height:37px;
            padding:5px;
            outline:none;
            margin:5px;
            text-align:center;
            border:solid 1px #000;
        }

        .inventory{
            display:flex;
            float:right;
            height:800px;
            width:200px;
            outline:none;
            padding:10px;
            z-index:9999;
        }

        .board{
            border:solid 1px #000;
            margin:auto;
        }

        .game{
            margin:auto;
            text-align:center;
        }

        tr:nth-child(1){
            font-weight: bold;
        }

        .tileButton{
            font-size:64px;
            width:100px;
            height: 100px;
            border-radius:100px;
            border:solid 1px #000;
        }

        .tileButton:hover{
            background:#fff;
        }

        .log{
            padding:10px;
            font-family: monospace;
            margin:10px;
            border:solid 1px #000;
            height:800px;
            width:200px;
            overflow: auto;
            outline:none;
            line-height: 1.8em;
        }

        .monsterInfo{
            min-width:200px;
            border:solid 1px #000;
            display:inline-block;
            padding:10px;
            margin:5px;
            text-align:left;
        }

        input{
            padding:10px;
            height:100%;
            border:solid 1px #000;
            outline:none;
        }

        @media print{
            #optionsContainer{
                display:none;
            }

            .page{

                width:8.5in;
                height:11in;
                border:none;
                padding:auto;
                margin:auto;
            }

            td{
                font-size:8px;
            }
            
            table,tr,td{
                border:solid 1px #000 !important;
            }

            table{
                margin:25px;
            }

            h2{
                font-size:16px;
                margin:25px;
            }

            .noprint{
                display:none;
            }
        }

    </style>
    <script src="gerosoup.js"></script>
</head>
<body>


    <h1>The Labyrinth of Tolgarith</h1>
    <!--
    <div class="page">
    <table>
        <tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
        <tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
        <tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
        <tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
        <tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
        <tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
        <tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
        <tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
    </table>
    -->

    <!--
    <div class="page">

        <pre>

            <b>Board Setup</b>

            Forest
                scatter rocks and crates, no long corridors or rooms

            Cave
                scatter rocks and crates, with long corridors, no rooms

            Village
                rooms and corridors with crates

            Castle
            TBD

            At the start you have a monster budget of 1, increasing by 1 per level (resetting at each area) and + 1 per area
            roll a D6 to determine what monster you fight and subtract it's cost from the budget for that round, continue to roll into you use up your budget, 
            the budget recalculates on the next level

            <b>Combat</b>

            the player(s) always move first, on your turn you can 
            
            move
            attack (consumes action)
            short rest (consumes action)
            long rest (consumes turn)
            change equipment (consumes action, can change everything in 1 turn)
            skip turn (consumes turn)

            you defeat an enemy by rolling their armor level or higher

            dumb enemies mindlessly charge at the nearest player, happily stepping on traps along the way
            mid enemies will only step on traps under certain circumstance but will otherwise charge the nearest player
            smart enemies will always avoid traps unless specified and will keep in the ideal range for their weapon, moving, attacking and moving away if possible

            enemy skills are listed by order, they will try and use the first ability that has an effect, moving through the list until something will hit 

            upon killing an enemy, roll a d4 if greater that 2, place a chest at their location, on pickup, roll a d4, 1-2 is D20 money, 3 is D20 Item, and 4 is D20 weapon
            
            if your hp is above 3 and you receive a strike that would kill you, you are still alive but must short rest within the next 5 turns

            every 5 levels before the enemies spawn a random merchant will appear, roll a d4 to decide

            1, 2 - traveling merchant, roll 4D20, they sells 3 items and 1 weapon, you can also sell to them

            3 - traveling scholar, roll 4D20, they sells 2 items and 2 spells, you can also sell to them

            4 - mysterious shadow, they sell all the items you've had on this and previous runs for 1.5x price 

            <hr>

        </pre>
    </div>
    -->

    <div id="optionsContainer"></div>
    <div id="monsterButtonList"></div>
</div>
    <script>
        
        const Colors = {
            primary:"#fff",
            secondary:"#000",
            attackOverlay:"#f00",
            moveOverlay:"#0f0"
        }

        const vp = new Viewport(window.innerWidth,window.innerHeight);
        const canvas = vp.canvas;
        
        const scene = new Scene(vp);
        scene.ui.color1 = Colors.primary;
        scene.ui.color2 = Colors.secondary;

        vp.camera = scene.camera;
        
        const ctx = canvas.getContext('2d');
        const grid = new Grid(8,8);
        const gridHighlights = new Grid(8,8);
        const gridNav = new Grid(8,8);

        gridHighlights.loop((x,y,v) => {
            gridHighlights.set(x,y,'rgba(0,0,0,0.0)');    
        });

        let baseData = {
            gold:0,
        };

        if(localStorage.save){
            baseData = JSON.parse(localStorage.save);
        }

        const save = new Proxy(baseData,{
            set(target, key, value) {
                target[key] = value;
                localStorage.save = JSON.stringify(target);
            },
            get(target,key){
                return target[key];
            }
        });

        let selected;
        let actors = [];
        let messageLog = [];
        const player = new BasePawn();
        player.ai = 0;

        const imgs = {};

        const tileSize = 32*3;
        const pieceSize = 64;

        imgs.bunny = loadImage('i/bunny.png');
        imgs.skull = loadImage('i/skull.png');
        imgs.rock = loadImage('i/rock.png');
        imgs.brick = loadImage('i/brick.png');
        imgs.orc = loadImage('i/orc.png');
        imgs.wolf = loadImage('i/wolf.png');
        imgs.golem = loadImage('i/golem.png');
        imgs.shadow = loadImage('i/shadow.png');
        imgs.zombie = loadImage('i/zombie.png');

        imgs.move = loadImage('i/move.png');
        imgs.target = loadImage('i/target.png');

        imgs.skeletonArcher = loadImage('i/skeleton_archer.png');
        imgs.skeletonWarrior = loadImage('i/skull.png');
        

        function loadImage(src){
            const img = new Image();
            img.src = src;
            return img;
        }

        const icon_lut = {
            '🪨':imgs.rock,
            'P':imgs.bunny,
            'O':imgs.orc,
            'W':imgs.wolf,
            "G":imgs.golem,
            "SW":imgs.skeletonWarrior,
            "SA":imgs.skeletonArcher,
            "Z":imgs.zombie
        };

        function note(a){
            messageLog.push(a);
            log.value += a+'\n';
            log.scrollTop = log.scrollHeight;
        }

        const tileOptions = "🐻🪨🎁🦇🕷️🦂";

        let wave = 0;
        let area = 'Forest';
        
        const display = document.createElement('p');

        updateDisplay();
        
        function rand(n){
            return Math.floor(Math.random() * n);
        }

        function d4(){
            return rand(4);
        }

        function d6(){
            return rand(6);
        }

        function d8(){
            return rand(8);
        }

        function d12(){
            return rand(12);
        }

        function d20(){
            return rand(20);
        }

        let turnDelay = 500;

        if(localStorage.turnDelay){
            turnDelay = parseInt(localStorage.turnDelay,10);
        }

        
        mouse = vp.mouse;

        const log = document.createElement('textarea');
        log.className = 'log';
        log.style.display = 'none';
        log.setAttribute('readonly',true);


        Array.prototype.push_unique = function(n){
            if(!this.includes(n)){
                this.push(n);
            }
        }

        function tableify(obj,title,columns=[],className=''){
            if(columns.length === 0){
                for(let key in obj){
                    for(let sub in obj[key]){
                        columns.push_unique(sub);
                    }
                }
            }

            const table = document.createElement('table');
            
            const tr = document.createElement('tr');
            table.appendChild(tr);

            const td = document.createElement('td');
            td.textContent = title;
            tr.appendChild(td);

            for(let item of columns){
                const td = document.createElement('td');
                td.textContent = item;
                tr.appendChild(td);
            }

            for(let key in obj){
                const tr = document.createElement('tr');
                table.appendChild(tr);

                const td = document.createElement('td');
                td.textContent = key;
                tr.appendChild(td);

                for(let item of columns){
                    const td = document.createElement('td');
                    td.textContent = obj[key][item] || '';
                    tr.appendChild(td);
                }

            }

            table.className = className;

            return table;

        }


        function updateDisplay(){
            display.textContent = `${area} - Wave: ${wave}`;
        }

        const items = {
            equipment:{
                Sword:{
                    stats:"D6",
                    special:"",
                    cost:30,
                    sell:15
                },
                Dagger:{
                    stats:"D4",
                    special:"Move +1",
                    cost:16,
                    sell:8
                },
                Bow:{
                    stats:"D6, Range 3 LoS",
                    special:"Uses arrows, can retrieve, comes with 3 arrows",
                    cost:40,
                    sell:20,
                    ammo:"Arrow"
                },
                Shield:{
                    stats:"Armor +2",
                    special:"Counter: if 1H in other hand, D4>2, Attack Attacker",
                    cost:30,
                    sell:15
                },
                Spear:{
                    stats:"D6, Range 2, Pierce",
                    special:"Throw: Range 3, can retrieve, Damage +2",
                    cost:24,
                    sell:12
                },
                Whip:{
                    stats:"D8, Range 2",
                    special:"Will Damage +2",
                    cost:40,
                    sell:20
                },
                Great_Sword:{
                    stats:"D12, Knockback +1",
                    special:"Move -1",
                    cost:80,
                    sell:40
                },
                Wand:{
                    stats:"D4 / 2",
                    special:"Spell Damage + 2, Catalyst",
                    cost:90,
                    sell:45
                },
                Staff:{
                    stats:"D4",
                    special:"Spell Damage + 4, Catalyst, 2 Hand	",
                    cost:90,
                    sell:45
                },
                Great_Shield:{
                    stats:"Armor +3",
                    special:"Move -1",
                    cost:80,
                    sell:40
                },
                Axe:{
                    stats:"D8",
                    special:"",
                    cost:30,
                    sell:15
                },
                Great_Axe:{
                    stats:"D20, Knockback +1",
                    special:"Move -2, Two Handed",
                    cost:100,
                    sell:50
                },
                Scythe:{
                    stats:"D8, Pierce",
                    special:"3 Targets in row, Two Handed, Catalyst",
                    cost:60,
                    sell:30
                },
                Hammer:{
                    stats:"D12, Knockback +3",
                    special:"Move -1",
                    cost:50,
                    sell:25
                },
                Crossbow:{
                    stats:"D12, Range 4",
                    special:"uses bolts, can retrieve, comes with 3 bolts",
                    cost:80,
                    sell:40,
                    ammo:"Bolt"
                },
                Bolt_Action_Rifle:{
                    stats:"D20, Range 8",
                    special:"consumes 1 bullet, must reload after shot (consumes turn)",
                    cost:120,
                    sell:60
                },
                Revolver:{
                    stats:"D12, Range 4",
                    special:"consumes 1 bullet, must reload after 6 shots (consumes turn)",
                    cost:140,
                    sell:70,
                    ammo:"Bullet"
                },
                Claws:{
                    stats:"2D6",
                    special:"Move +1",
                    cost:40,
                    sell:20
                },
                Grimoire:{
                    stats:"D4 / 2",
                    special:"Spell Damage +2, has 2 random spells on pickup, Catalyst",
                    cost:-1,
                    sell:300
                },
                Iron_Gauntlets:{
                    stats:"2D4",
                    special:"Move +1, Grab Ability: D6 > target move - target weight, throw to any nearby tile",
                    cost:40,
                    sell:20
                }
            },
            items:{
                Health_Potion:{
                    type:"Consumable",
                    effect:"Heal +5",
                    cost:5,
                    sell:5
                },
                Arrow:{
                    type:"Ammo",
                    effect:"Reusable, Enchantable",
                    cost:2,
                    sell:2
                },
                Bolt:{
                    type:"Ammo",
                    effect:"Reusable, Enchantable",
                    cost:2,
                    sell:2
                },
                Bullet:{
                    type:"Ammo",
                    effect:"Not Enchantable",
                    cost:3,
                    sell:2
                },
                Poison:{
                    type:"Consumable",
                    effect:"Apply to Sharp Weapon / Arrow / Bait, +2 Damage on targets with flesh for next 3 turns"
                },
                Bait:{
                    type:"Consumable",
                    effect:"Lure enemy to location, works with traps and poison",
                    cost:5,
                    sell:2.5
                },
                Anchor_Trap:{
                    type:"Trap",
                    effect:"D4 > 1 Enemy is trapped for 2 turns, explodes when stepping off",
                    cost:10,
                    sell:5
                },
                Bomb_Trap:{
                    type:"Trap",
                    effect:"D8 to tile and nearby surrounding tiles, explodes when stepping off",
                    cost:20,
                    sell:10
                },
                Sleep_Trap:{
                    type:"Trap",
                    effect:"D4 > 1 puts living enemies to sleep, explodes when stepping off",
                    cost:10,
                    sell:5
                },
                Whiskey:{
                    type:"Consumable",
                    effect:"increase max health by 5 for 3 turns, -1 to dodge rolls",
                    cost:15,
                    sell:10
                },
            },
            Armor:{
                Gas_Mask:{
                    type:"Equipable",
                    slot:"Head",
                    effect:"grants resistance to Sleep trap, Gas and Smells",
                    cost:30,
                    sell:15
                },
                Basic_Armor:{
                    type:"Equipable",
                    slot:"Body",
                    effect:"Armor +1",
                    cost:50,
                    sell:25
                },
                Full_Plate_Armor:{
                    type:"Equipable",
                    slot:"Body",
                    effect:"Armor +2, Move -1",
                    cost:80,
                    sell:40
                }
            },
            Abilities:{
                Fireball:{
                    cooldown:1,
                    ability:"D6 R3, Fire Damage, hits all nearby squares",
                    cost:120,
                    sell:60
                },
                Raise_Dead:{
                    cooldown:2,
                    ability:"Corpse + D4 > 1, raise Controllable Zombie",
                    cost:120,
                    sell:60
                },
                Chilling_Touch:{
                    cooldown:1,
                    ability:"Target has half movement speed for 2 turns",
                    cost:120,
                    sell:60
                },
                Draining_Kiss:{
                    cooldown:1,
                    ability:"D6, caster gains damage as health; if target tranced, target loses next turn",
                    cost:120,
                    sell:60
                },
                Trance:{
                    cooldown:2,
                    ability:"R2 target involuntarily moves towards caster for 2 turns and cannot attack caster, ends early if target is hurt",
                    cost:120,
                    sell:60
                },
                Howl:{
                    cooldown:2,
                    ability:"R2 Allies gain +2 Damage for 1 turn",
                    cost:120,
                    sell:60
                },
                Blink:{
                    cooldown:3,
                    ability:"teleport R5, if D4 > 3 can go through walls, otherwise end at wall",
                    cost:120,
                    sell:60
                },
                Blessing:{
                    cooldown:3,
                    ability:"R3 Heal target for D6, if target doesn't have health, give 1 hp barrier",
                    cost:120,
                    sell:60
                },
                Twist_Stone:{
                    cooldown:3,
                    ability:"Create Stone or Remove Stone",
                    cost:120,
                    sell:60
                },
                Reflect:{
                    cooldown:3,
                    ability:"R2 Reflect next damage taken on attacker, up to R2",
                    cost:120,
                    sell:60
                },
                Shift_Position:{
                    cooldown:3,
                    ability:"D4 > 1; exchange places with target, R4",
                    cost:120,
                    sell:60
                },
                Pushing_Gale:{
                    cooldown:2,
                    ability:"R2 throw target up to R4 away from caster (as far as possible)",
                    cost:120,
                    sell:60
                },
                Pulling_Gale:{
                    cooldown:2,
                    ability:"R4 pull target to caster",
                    cost:120,
                    sell:60
                },
                Resurrect:{
                    cooldown:1,
                    ability:"Raise dead Ally to 50% health, drains casters health to 1",
                    cost:120,
                    sell:60
                },
                Raise_Shadow:{
                    cooldown:2,
                    ability:"Create controllable Shadow Creature, caster loses 5 hp",
                    cost:120,
                    sell:60
                },
                Double_Time:{
                    cooldown:2,
                    ability:"target gets 2 turns this round, back to back or additional turn after caster if already completed turn",
                    cost:120,
                    sell:60
                },
                Mana_Bomb:{
                    cooldown:2,
                    ability:"R2 place large bomb, explodes in 2 turns for D12 damage to tile and surrounding tiles",
                    cost:120,
                    sell:60
                },
                Blood_Bow:{
                    cooldown:1,
                    ability:"R6, D6, caster loses 1hp ",
                    cost:120,
                    sell:60
                },
                Anchor:{
                    cooldown:2,
                    ability:"target cannot move for 1 turn",
                    cost:120,
                    sell:60
                },
                Gel:{
                    cooldown:3,
                    ability:"target loses next turn",
                    cost:120,
                    sell:60
                }
            }
        }

        const item_lut = {};

        for(let type in items){
            for(let name in items[type]){
                item_lut[name] = items[type][name];
                item_lut[name].type = type;
            }
        }

        const monsters = {
            Forest:{
                Zombie:{
                    image:imgs.zombie,
                    move:1,
                    armor:3,
                    int:"Dumb",
                    attack:"D4",
                    cost:1
                },
                Wolf:{
                    image:imgs.wolf,
                    move:3,
                    armor:2,
                    int:"Dumb",
                    attack:"D6",
                    cost:3
                },
                Orc:{
                    image:imgs.orc,
                    move:2,
                    armor:3,
                    int:"Mid",
                    attack:"D6",
                    cost:3
                },
                Golem:{
                    image:imgs.golem,
                    move:1,
                    armor:4,
                    int:"Dumb",
                    attack:"D12",
                    cost:3
                },
                Skeleton_Warrior:{
                    image:imgs.skeletonWarrior,
                    move:2,
                    armor:2,
                    int:"Dumb",
                    attack:"D4",
                    cost:2
                },
                Skeleton_Archer:{
                    image:imgs.skeletonArcher,
                    move:2,
                    armor:2,
                    int:"Smart",
                    attack:"D6 R3",
                    cost:3
                }
            },
            Caves:{
                Slime:{
                    move:2,
                    armor:4,
                    int:"Dumb",
                    attack:"D4",
                    cost:1
                },
                Bat:{
                    move:4,
                    armor:1,
                    int:"Dumb",
                    attack:"D6",
                    cost:2
                },
                Goblin_Archer:{
                    move:2,
                    armor:2,
                    int:"Dumb",
                    attack:"D6 R3",
                    cost:1
                },
                Necromancer:{
                    move:2,
                    armor:4,
                    int:"Smart",
                    attack:"Raise Undead; Vampiric Touch; D4",
                    cost:4
                },
                Werewolf:{
                    move:4,
                    armor:4,
                    int:"Dumb",
                    attack:"D8",
                    cost:5
                },
                Goblin_Medic:{
                    move:3,
                    armor:2,
                    int:"Smart",
                    attack:"Healing Touch; D6",
                    cost:3
                }
            },
            Village:{
                Enchanted_Wolf:{
                    move:3,
                    armor:3,
                    int:"Dumb",
                    attack:"D8; Howl",
                    cost:2
                },
                Enchanted_Bat:{
                    move:4,
                    armor:2,
                    int:"Dumb",
                    attack:"D8",
                    cost:0
                },
                Enslaved_Villager:{
                    move:2,
                    armor:2,
                    int:"Dumb",
                    attack:"D6 R2 Pierce",
                    cost:1
                },
                Enslaved_Soldier:{
                    move:2,
                    armor:4,
                    int:"Smart",
                    attack:"D8; can dodge",
                    cost:3
                },
                Enslaved_Archer:{
                    move:3,
                    armor:4,
                    int:"Smart",
                    attack:"D6 R3",
                    cost:3
                },
                Minor_Succubus:{
                    move:3,
                    hp:6,
                    armor:4,
                    int:"Smart",
                    attack:"Draining Kiss, Trance, D6; can dodge",
                    cost:3
                }
            }
        }

        let playerInventory = {};

        for(let type in items){
            for(let name in items[type]){
                playerInventory[name] = {
                    quantity:1,
                    selected:false
                };
            }
        }

        for(let key in monsters){
            let i = 1;
            for(let entry in monsters[key]){
                monsters[key][entry].hp = monsters[key][entry].hp || 1; 
                monsters[key][entry].roll = i;
                i += 1;
            }
        }

        for(let key in items){
            let i = 1;
            for(let item in items[key]){
                items[key][item].roll = i;
                i+= 1;
            }
        }

        //renderInventory();
    
        function monsterStats(monster){
            monster = monster.replace(' ','_');
            for(let key in monsters){
                if(monsters[key][monster]){
                    const data = monsters[key][monster];
                    return `<h3>${monster.replace('_',' ')}</h3> Armor ${data.armor},  Move ${data.move}, Attack ${data.attack}, ${data.int}`;
                }
            }
        }

        function getMonster(monster){
            monster = monster.replace(' ','_');
            for(let key in monsters){
                if(monsters[key][monster]){
                    return monsters[key][monster];
                }
            }
        }

        nextWave();


        /*
        for(let area in monsters){
            for(let monster in monsters[area]){
                const button = document.createElement('button');
                button.textContent = monster.split('_').join(' ');
                button.addEventListener('mousedown',function(){
                    spawnMonster(monster);
                });
                monsterButtonList.appendChild(button);
            }
        }
        */

        function rollButton(text,func,parent=optionsContainer){
            const button = document.createElement('button');
            button.textContent = text;
            button.addEventListener('mousedown',function(){
                note("rolled a "+text+": "+(func()+1))
            });
           parent.appendChild(button);
        }

        setupGame(document.body);


        const game = new Game(); 
        scene.add(game);

        function Action(){
            this.icon = '';
            this.render = function(ctx){

            }
            this.description = '';
            this.callback = function(self,target,x,y){

            }
        }

        function ActionMove(){
            this.icon = imgs.move;
            this.description = 'move to location';
            this.callback = function(self,target,x,y){
                self.x = x;
                self.y = y;
            }   
        }

        function ActionPush(){

        }

        function toInt(str){
            str = str.replace(/\D/g,'');
            return parseInt(str,10);
        }

        function parseWeaponStats(n){
            
            const parts = n.toLowerCase().split(' ');

            let obj = {
                damage:0,
                range:1,
                count:1,
                los:false
            };

            for(let p of parts){
                if(p.includes('d')){
                    obj.damage = toInt(p);
                }else if(p.includes('r')){
                    obj.range = toInt(p);
                }else if(p.includes('los')){
                    obj.los = true;
                }
            }
            return obj;
        }

        function BasePawn(){
            this.name = '';
            this.health = 10;
            this.armor = 0;
            this.movementSpeed = 0;
            this.hero = false;
            this.steps = 0;
            this.attackCount = 1;
            this.position = vec2(0,0);
            this.displayPosition = vec2(0,0);
            this.attackDice = 0;
            this.attacked = 0;
            this.moved = 0;
            this.attackRange = 0;
            this.iq = 0;
            this.ai = 1;
            this.slots = [false,false,false,false];
            this.active = false;
            this.activeWeapon;
            this.attackRangeLoS = false;
            this.inventory = []

            this.actions = {
                move:ActionMove,
                push:ActionPush
            };

            this.rest = function(){
                const healAmount = rand(4)+1;
                this.health += healAmount;
                this.health = Math.min(this.health,this.maxHealth);
                this.note('rested and healed '+healAmount);
                this.attacked = this.attackCount;
            }

            this.showMoveGrid = function(){
                gridHighlights.floodFill(this.position.x,this.position.y,1,isSolidOccupied,1);
            }

            this.showAttackRange = function(){
                gridHighlights.loop((x,y,v) => {
                    gridHighlights.set(x,y,false);
                });
                if(this.activeWeapon && this.activeWeapon.los){
                    gridHighlights.setRaycast(this.position.x,this.position.y,0,1,2,isSolidOccupiedAttackable);
                    gridHighlights.setRaycast(this.position.x,this.position.y,0,-1,2,isSolidOccupiedAttackable);
                    gridHighlights.setRaycast(this.position.x,this.position.y,1,0,2,isSolidOccupiedAttackable);
                    gridHighlights.setRaycast(this.position.x,this.position.y,-1,0,2,isSolidOccupiedAttackable);
                    gridHighlights.setRaycast(this.position.x,this.position.y,1,1,2,isSolidOccupiedAttackable);
                    gridHighlights.setRaycast(this.position.x,this.position.y,-1,1,2,isSolidOccupiedAttackable);
                    gridHighlights.setRaycast(this.position.x,this.position.y,1,-1,2,isSolidOccupiedAttackable);
                    gridHighlights.setRaycast(this.position.x,this.position.y,-1,-1,2,isSolidOccupiedAttackable);
                }else{
                    gridHighlights.floodFill(this.position.x,this.position.y,2,isSolidOccupiedAttackable,this.attackRange);
                }
            }   

            this.setWeapon = function(type,slot){
                const weapon = items.equipment[type];
                const stats = parseWeaponStats(weapon.stats);
                this.attackCount = stats.count;
                this.damage = stats.damage;
                this.attackRange = stats.range;
                this.attackRangeLoS = stats.los
                this.activeWeapon = stats;
                this.slots[slot] = type;
            }

            this.getClosestTarget = function(){
                let dis = Infinity;
                let closest = false;
                for(let actor of actors){
                    if(actor !== this){
                        const d = this.distance(this.position.x,this.position.y,actor.position.x,actor.position.y);
                        if(d < dis){
                            dis = d;
                            closest = actor;
                        }
                    }
                }
                return closest;
            }
            
            this.canMove = function(){
                return (this.movementSpeed - this.moved) > 0;
            }     

            this.canAttack = function(){
                return (this.attackCount - this.attacked) > 0;
            }

            this.navCloser = function(){
                let lowest = Infinity;
                let dir = V2.cardinal.random();
                for(let d of V2.cardinal){
                    const direction = vec2(this.position.x+d.x,this.position.y+d.y);
                    const n = gridNav.get(direction.x,direction.y,99);
                    if(n !== false && n < lowest){
                        lowest = n;
                        dir = d;
                    }
                }
                this.moveDirection(dir);
                return this.distance(gridNav.target.x,gridNav.target.y);
            }

            this.navFurther = function(){
                let highest = -Infinity;
                let dir = V2.cardinal.random();
                for(let d of V2.cardinal){
                    const direction = vec2(this.position.x+d.x,this.position.y+d.y);
                    const n = gridNav.get(direction.x,direction.y,0);
                    if(n !== false && n > highest){
                        highest = n;
                        dir = d;
                    }
                }
                this.note(dir);
                this.moveDirection(dir);
                return this.distance(gridNav.target.x,gridNav.target.y);
            }

            this.distance = function(x,y){
                return grid.distanceDiagonal(this.position.x,this.position.y,x,y);
            }
            this.moveDirection = function(dir){
                this.move(
                    this.position.x+dir.x,
                    this.position.y+dir.y
                );
            }
            this.note = function(n){
                note(n);
                scene.add(new FloatingText(n,this.position.x*tileSize+tileSize*0.5,this.position.y * tileSize+Math.random()*20-10));
            }
            this.remove = function(){
                grid.set(this.position.x,this.position.y,0);
                const i = actors.indexOf(this);
                actors.splice(i,1);
                scene.remove(this);
                this.note(this.name + ' died');
            };
            this.shake = function(n=0.25){
                this.displayPosition.x += Math.random() * n - (n * 0.5);
                this.displayPosition.y += Math.random() * n - (n * 0.5);
                if(n>0){
                    const self = this;
                    setTimeout(() => {
                        self.shake(n*0.5);
                    },250);
                }
            }
            this.hurt = function(attacker,baseDamage){
                let damage = baseDamage - Math.max(this.armor - 1,0);
                this.shake(0.25);
                if(damage <= 0){
                    this.note(attacker.name +"'s "+baseDamage+" bounces off "+this.name+"'s "+this.armor+" armor");
                }else{
                    this.health -= damage;
                    if(this.health <= 0){
                        this.note(this.name + " took "+damage+"dmg! they died");
                        if(this.hero){
                            window.location.reload();
                            return;
                        }
                        this.remove();
                        this.position.x += Math.floor(Math.random() * 20) - 10;
                        this.position.y += Math.floor(Math.random() * 20) - 10;
                    }else{
                        this.note(this.name+" takes " + damage +" damage! "+this.health +" left");
                    }
                }
            };

            this.attack = function(target){
                if(this.canAttack()){
                    gridHighlights.setAll(false);
                    this.showAttackRange();
                    if(gridHighlights.get(target.position.x,target.position.y)===2){
                        this.attacked += 1;
                        target.hurt(this,this.roll(this.attackDice)+1);
                    }
                }
            }

            this.roll = function(n){
                const r = rand(n)+1;
                this.note(this.name + " rolled d"+n+', lands on '+r);
                return r;
            }

            this.attemptAttack = function(target){
                
                if(!target.hurt){
                    return;
                }

                this.attack(target);

            }
            this.move = function(x,y){

                if(grid.get(x,y)){
                    this.moved += 1; //if you don't eat a move for a fail AI get's trapped
                    return;
                }

                var dis = Math.max(Math.abs(x-this.position.x), Math.abs(y-this.position.y));
                
                if(dis > this.movementSpeed-this.moved){
                    this.moved += 1; //if you don't eat a move for a fail AI get's trapped
                    return;
                }

                grid.set(this.position.x,this.position.y,0);
                grid.set(x,y,this);
                this.moved += dis;
                this.position.x = x;
                this.position.y = y;
            }
            actors.push(this);
            this.update = function(delta){
                const d = (delta * 8) / (turnDelay / 1000);
                this.displayPosition.x = Math.lerp(this.displayPosition.x,this.position.x,d);
                this.displayPosition.y = Math.lerp(this.displayPosition.y,this.position.y,d);
            
            }
            scene.add(this);
        }

        function FloatingText(txt,x,y){
            this.position = vec2(x,y);
            this.ttl = 3.0
            this.render = function(ctx){
                ctx.strokeStyle = '#000';
                ctx.fillStyle = '#fff';
                ctx.font = '16px monospace';
                ctx.textAlign = 'center';
                ctx.outlineText(txt,this.position.x,this.position.y);
            }
            this.update = function(delta){
                this.position.y -= delta * 60.0;
                this.ttl -= delta
                if(this.ttl <= 0){
                    scene.remove(this);
                }
            }
        }

        function setupGame(container){
            
            let current_tile = '';

            const w = tileSize*8;
            const h = tileSize*8;
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            window.addEventListener('resize',function(){
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            },false);
            canvas.className = 'board';
            container.appendChild(canvas);


            for(let i = 0; i < 9; i++){
                
                const x = rand(8);
                const y = rand(8);

                grid.set(x,y,'🪨');

            }

            const a = d4();
            const b = d4();
            const c = d4();

            player.health = player.maxHealth = 10;
            player.movementSpeed = 3;
            player.attackDice = 6;
            player.attackRange = 1;
            player.name = 'Player';
            player.hero = true;
            player.image = imgs.bunny;
            var g = grid.quadraticToGrid(a,b,c);
            grid.quadraticSet(a,b,c,player);
            player.position.x = g.x;
            player.setWeapon('Bow',1);
            player.setWeapon('Sword',0);

            player.position.y = g.y;
            player.displayPosition.x = g.x;
            player.displayPosition.y = g.y;

        }

        function render(){

            ctx.clearRect(0,0,canvas.width,canvas.height);

            ctx.font = '40px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = "middle";
            ctx.imageSmoothingEnabled = false;
            const s = tileSize;
            const hs = s * 0.5;
            ctx.fillStyle = Colors.secondary;
            ctx.lineWidth = 1;
            
            grid.loop((x,y,v) => {
                ctx.drawImage(imgs.brick,0,0,16,16,x*s,y*s,s,s);
            });

            const hps = pieceSize * 0.5;

            ctx.strokeStyle = Colors.primary;
            ctx.lineWidth = 5;
            grid.loop((x,y,v) => {
                if(v){

                    let px = x*s+hs-hps;
                    let py = y*s+hs-hps;

                    if(v.active){
                        ctx.strokeStyle = Colors.secondary;
                        ctx.strokeCircle(px+tileSize*0.5,py+tileSize*0.5,20);
                        ctx.strokeStyle = Colors.primary
                    }

                    if(icon_lut[v]){
                        //ctx.globalAlpha = 0.2;
                        //ctx.drawImage(imgs.shadow,0,0,16,16,x*s+hs-hps,y*s+hs-hps+8,pieceSize,pieceSize);
                        //ctx.globalAlpha = 1.0;
                        ctx.drawImage(icon_lut[v],0,0,16,16,x*s+hs-hps,y*s+hs-hps,pieceSize,pieceSize);
                    }else if(v.image){

                        x = v.displayPosition.x;
                        y = v.displayPosition.y;

                        px = x*s+hs-hps;
                        py = y*s+hs-hps;
                        
                        let movesLeft = v.movementSpeed - v.moved;
                        let attacksLeft = v.attackCount-v.attacked;
                        
                        if(movesLeft + attacksLeft === 0){
                            ctx.globalAlpha = 0.5;
                        }

                        if(v.health <= 0){
                            ctx.globalAlpha = 0.25;
                        }

                        ctx.font = '16px monospace';
                        ctx.drawImage(v.image,0,0,16,16,px,py,pieceSize,pieceSize);
                        ctx.globalAlpha = 1.0;

                        ctx.fillStyle = Colors.moveOverlay
                        ctx.strokeText(movesLeft,px,py-hps*0.33);
                        ctx.fillText(movesLeft,px,py-hps*0.33);
                        ctx.fillStyle = 'red';
                        ctx.strokeText(attacksLeft,px+pieceSize,py-hps*0.33);
                        ctx.fillText(attacksLeft,px+pieceSize,py-hps*0.33);
                        
                        ctx.fillStyle = 'red';
                        ctx.outlineText(v.attackDice,px+pieceSize,py+pieceSize);
                        ctx.fillStyle = 'grey';
                        ctx.outlineText(v.armor,px,py+pieceSize);
                        const hpy = 5;
                        py += 10;
                        ctx.strokeRect(px,py+pieceSize, pieceSize,hpy);
                        ctx.fillRect(px,py+pieceSize, (v.health/v.maxHealth) * pieceSize,hpy);
                        ctx.globalAlpha = 1.0;
                        
                        
                    }else{
                        ctx.fillText(v,x*s+hs,y*s+hs);
                    }
                }
            });

            gridHighlights.loop((x,y,v) => {
                if(v === 1){
                    ctx.drawImage(imgs.move,0,0,16,16,x*s+hs*0.5,y*s+hs*0.5,hs,hs);
                }else if(v === 2){
                    ctx.drawImage(imgs.target,0,0,16,16,x*s+hs*0.5,y*s+hs*0.5,hs,hs); 
                }
            });

            ctx.fillStyle = Colors.primary;
            ctx.strokeStyle = Colors.secondary;
            if(save.debugNav){
                gridNav.loop((x,y,v) => {
                    const px = x*s+hs;
                    const py = y*s+hs;
                    ctx.outlineText(v,px,py);
                });
            }

            if(selected){
                const ps = pieceSize * 0.75;
                const x = mouse.gx;
                const y = mouse.gy;
                if(selected.canMove()){
                    if (gridHighlights.get(x,y) === 1){
                        ctx.strokeStyle = Colors.moveOverlay;
                        ctx.beginPath();
                        ctx.lineTo(selected.position.x*s+hs,selected.position.y*s+hs);
                        ctx.lineTo(x*s+hs,y*s+hs);
                        ctx.stroke();
                        if(icon_lut[selected]){
                            ctx.drawImage(icon_lut[selected],0,0,16,16,x*s+ps*0.5,y*s+ps*0.5,ps,ps);
                        }else if(selected.image){
                            ctx.drawImage(selected.image,0,0,16,16,x*s+hs-hps,y*s+hs-hps,pieceSize,pieceSize);
                        }else{
                            ctx.fillText(initials(selected.name),x*s+hs,y*s+hs);
                        }
                    }
                }else if(selected.canAttack()){
                    if(grid.get(x,y) && gridHighlights.get(x,y) === 2){
                        ctx.drawImage(imgs.target,0,0,16,16,x*s+hs-hps,y*s+hs-hps,pieceSize,pieceSize);
                    }
                }
            }
            //ctx.strokeStyle = 'rgba(0,0,0,0.25)';
            //const padding = 20;
            //ctx.strokeRect(mouse.gx*tileSize+padding,mouse.gy*tileSize+padding,tileSize-padding*2,tileSize-padding*2);
        }

        function Grid(w,h){
            const data = [];
            this.data = data;
            this.target = vec2(-1,-1);
            for(let i = 0; i < w * h; i++){
                data.push(0);
            }
            this.validPosition = function(x,y){
                if(x < 0 || x >= w) return false;
                if(y < 0 || y >= h) return false;
                return true;
            }

            this.setRaycast = function(sx,sy,dirX,dirY,v,isSolid){
                sx += dirX;
                sy += dirY;
                while(!isSolid(sx,sy)){
                    this.set(sx,sy,v);
                    sx += dirX;
                    sy += dirY;
                }
            }

            this.raycast = function(x,y,dirX,dirY,isSolid,callback){
                while(!isSolid(x,y)){
                    x += dirX;
                    y += dirY;
                    callback(x,y);
                }
            }

            this.get = function(x,y,def=-1){
                if(!this.validPosition(x,y)){
                    return def;
                }
                const id = x + y * w;
                if(id > data.length-1 || id < 0){
                    return def;
                }
                return data[id];
            }
            this.set = function(x,y,v){
                const id = x + y * w;
                if(id > data.length-1 || id < 0){
                    return false
                }
                data[id] = v;
                return true;
            };


            this.navFill = function(x,y,isSolid){

                this.loop((x,y) => {
                    this.set(x,y,false);
                })

                let visited = {};
                let frontlines = [];

                this.target.x = x;
                this.target.y = y;

                function push(x,y,dis){
                    const id = (x + y * w).toString();
                    if(!visited[id] && !isSolid(x,y)){
                        visited[id] = true;
                        frontlines.push([x,y,dis+1]);
                    }
                }

                push(x+1,y,0);
                push(x-1,y,0);
                push(x,y+1,0);
                push(x,y-1,0);

                /*
                push(x+1,y+1,0);
                push(x-1,y-1,0);
                push(x-1,y+1,0);
                push(x+1,y-1,0);
                */
                while(frontlines.length>0){
                    var next = frontlines.shift();
                    push(next[0]+1,next[1],next[2]);
                    push(next[0]-1,next[1],next[2]);
                    push(next[0],next[1]+1,next[2]);
                    push(next[0],next[1]-1,next[2]);
                    /*
                    push(next[0]+1,next[1]+1,next[2]);
                    push(next[0]-1,next[1]-1,next[2]);
                    push(next[0]-1,next[1]+1,next[2]);
                    push(next[0]+1,next[1]-1,next[2]);
                    */
                    
                    this.set(next[0],next[1],next[2]);
                }
                this.set(x,y,0);
            };

            this.drawAttackableFlood = function(x,y,isSolid,r=1){
                let visited = {};
                let frontlines = [];
                
                if(r <= 0){
                    return;
                }
                ctx.lineWidth = 1;
                ctx.strokeStyle = Colors.attackOverlay;
                function push(x,y,dis){
                    if(dis >= r){
                        return;
                    } 
                    const id = (x + y * w).toString();
                    if(!visited[id] && !isSolid(x,y)){
                        visited[id] = true;
                        frontlines.push([x,y,dis+1]);
                    }
                   const ts = tileSize * 0.5;
                   if(x >= 0 && x < 7 && y >= 0 && y < 7){
                    ctx.strokeCircle(x*tileSize+ts,y*tileSize+ts,ts*0.5);
                   }
                }

                push(x+1,y,0);
                push(x-1,y,0);
                push(x,y+1,0);
                push(x,y-1,0);

                /*
                push(x+1,y+1,0);
                push(x-1,y-1,0);
                push(x-1,y+1,0);
                push(x+1,y-1,0);
                */
                while(frontlines.length>0){
                    var next = frontlines.shift();
                    push(next[0]+1,next[1],next[2]);
                    push(next[0]-1,next[1],next[2]);
                    push(next[0],next[1]+1,next[2]);
                    push(next[0],next[1]-1,next[2]);
                    /*
                    push(next[0]+1,next[1]+1,next[2]);
                    push(next[0]-1,next[1]-1,next[2]);
                    push(next[0]-1,next[1]+1,next[2]);
                    push(next[0]+1,next[1]-1,next[2]);
                    */
                }
            };


            this.floodDraw = function(x,y,isSolid,r=1){
                let visited = {};
                let frontlines = [];
                
                if(r <= 0){
                    return;
                }

                function push(x,y,dis){
                    if(dis >= r){
                        return;
                    } 
                    const id = (x + y * w).toString();
                    if(!visited[id] && !isSolid(x,y)){
                        visited[id] = true;
                        frontlines.push([x,y,dis+1]);
                    }
                }

                push(x+1,y,0);
                push(x-1,y,0);
                push(x,y+1,0);
                push(x,y-1,0);

                /*
                push(x+1,y+1,0);
                push(x-1,y-1,0);
                push(x-1,y+1,0);
                push(x+1,y-1,0);
                */
               const ts = tileSize * 0.5;
                while(frontlines.length>0){
                    var next = frontlines.shift();
                    push(next[0]+1,next[1],next[2]);
                    push(next[0]-1,next[1],next[2]);
                    push(next[0],next[1]+1,next[2]);
                    push(next[0],next[1]-1,next[2]);
                    /*
                    push(next[0]+1,next[1]+1,next[2]);
                    push(next[0]-1,next[1]-1,next[2]);
                    push(next[0]-1,next[1]+1,next[2]);
                    push(next[0]+1,next[1]-1,next[2]);
                    */
                   ctx.fillCircle(next[0]*tileSize+ts,next[1]*tileSize+ts,ts*0.25);
                }
            };

            this.floodFill = function(x,y,v,isSolid,r=1){
                let visited = {};
                let frontlines = [];
                
                if(r <= 0){
                    return;
                }

                function push(x,y,dis){
                    if(dis >= r){
                        return;
                    } 
                    const id = (x + y * w).toString();
                    if(!visited[id] && !isSolid(x,y)){
                        visited[id] = true;
                        frontlines.push([x,y,dis+1]);
                    }
                }

                push(x+1,y,0);
                push(x-1,y,0);
                push(x,y+1,0);
                push(x,y-1,0);

                /*
                push(x+1,y+1,0);
                push(x-1,y-1,0);
                push(x-1,y+1,0);
                push(x+1,y-1,0);
                */
                while(frontlines.length>0){
                    var next = frontlines.shift();
                    push(next[0]+1,next[1],next[2]);
                    push(next[0]-1,next[1],next[2]);
                    push(next[0],next[1]+1,next[2]);
                    push(next[0],next[1]-1,next[2]);
                    /*
                    push(next[0]+1,next[1]+1,next[2]);
                    push(next[0]-1,next[1]-1,next[2]);
                    push(next[0]-1,next[1]+1,next[2]);
                    push(next[0]+1,next[1]-1,next[2]);
                    */
                    this.set(next[0],next[1],v);
                }
            };

            this.loop =function(callback){
                for(let x = 0; x < w; x++){
                    for(let y = 0; y < h; y++){
                        callback(x,y,data[x+y*w]);
                    }
                }
            }

            this.setAll =function(v){
                for(let i = 0; i < w * h; i++){
                    data[i] = v;
                }
            }
            this.quadraticToGrid = function(a,b,c){
                let x = 0;
                let y = 0;
                let lut = [
                    [1,0],
                    [1,1],
                    [0,1],
                    [0,0]
                ];
                const aa = lut[a];
                const bb = lut[b];
                const cc = lut[c];

                x += aa[0] * 4;
                y += aa[1] * 4;

                x += bb[0] * 2;
                y += bb[1] * 2;
                
                x += cc[0];
                y += cc[1];
                return vec2(x,y);
            }
            this.quadraticSet = function(a,b,c,v){
                let x = 0;
                let y = 0;
                let lut = [
                    [1,0],
                    [1,1],
                    [0,1],
                    [0,0]
                ];
                const aa = lut[a];
                const bb = lut[b];
                const cc = lut[c];

                x += aa[0] * 4;
                y += aa[1] * 4;

                x += bb[0] * 2;
                y += bb[1] * 2;
                
                x += cc[0];
                y += cc[1];
                const id = x + y * w;
                if(id > data.length-1 || id < 0){
                    return false
                }
                data[id] = v;
                return true;
            }

            this.quadraticGet = function(a,b,c,v){
                let x = 0;
                let y = 0;
                let lut = [
                    [1,0],
                    [1,1],
                    [0,1],
                    [0,0]
                ];
                const aa = lut[a];
                const bb = lut[b];
                const cc = lut[c];

                x += aa[0] * 4;
                y += aa[1] * 4;

                x += bb[0] * 2;
                y += bb[1] * 2;
                
                x += cc[0];
                y += cc[1];
                const id = x + y * w;
                if(id > data.length-1 || id < 0){
                    return undefined;
                }
                return data[id];
            }

            this.distance = function(x1,y1,x2,y2){
                return Math.max(Math.abs(x1-x2),Math.abs(y1-y2));
            }

            this.distanceDiagonal = function(x1,y1,x2,y2){
                return Math.abs(x1-x2) + Math.abs(y1-y2);
            }
        }

        function loop(){
            requestAnimationFrame(loop);
            render();
        }

        //loop();

        function counter(n,callback){
            const span = document.createElement('span');
            span.className = 'counter';
            
            const out = document.createElement('span');
            
            const lower =document.createElement('button');
            lower.addEventListener('mousedown',function(){
                n -= 1
                out.textContent = n;
                callback(n);
            });
            lower.textContent = '<';
            
            const higher =document.createElement('button');
            higher.addEventListener('mousedown',function(){
                n += 1
                out.textContent = n;
                callback(n);
            });
            higher.textContent = '>';

            out.textContent = n;
            span.appendChild(lower);
            span.appendChild(out);
            span.appendChild(higher);
            return span;    
        }

        function getQuadraticPlayerPosition(){
            let pos;
            grid.loop(function(x,y,v){
                if(v === 'P'){

                }
            })
        }

        function nextTurn(){
            
            let cursor = 0;
            let delay = turnDelay;

            function next(){
                setTimeout(next,delay);

                game.tick += 1;
                game.actorCursor = cursor;
                for(let turn of actors){
                    turn.active = false;
                }

                if(actors.length == 1){
                    nextWave();
                    note("Next wave!");
                }

                if(actors[cursor]){
                    const current = actors[cursor];
                    
                    if(current.health <= 0){
                        cursor += 1;
                        next();
                        return;
                    }

                    /* comment / uncomment for auto play
                    if(current.hero && (current.canMove() || current.canAttack() ) ){
                        return;
                    } 
                    //*/

                    if(!current.canMove() && !current.canAttack()){
                        cursor += 1;
                    }else{

                        actors[cursor].active = true;

                        if(current.ai > 0){
                            const target = current.getClosestTarget();
                            gridNav.navFill(target.position.x,target.position.y,isSolidOccupied);

                            if(this.health / this.maxHealth < 0.5){
                                if(current.canMove()){
                                    current.navFurther();
                                }else{
                                    current.rest();
                                }
                                return;
                            }

                            //todo calculate safest tiles and try to end turn on safest tile

                            if(current.canAttack()){
                                //adjust distance
                                let distance = current.distance(target.position.x,target.position.y);
                                if(distance > current.attackRange){
                                    distance = current.navCloser();
                                    current.note("move closer");
                                }else if(current.attackRange === distance){
                                    current.note("good range");
                                    current.moved = current.movementSpeed;
                                }else{
                                    current.note("move further");
                                    distance = current.navFurther();
                                }

                                //attack if possible
                                if(distance <= current.attackRange){
                                    current.attack(target);
                                    current.note("attack!");
                                }else if(!current.canMove()){ // if out of range, end turn
                                    current.note("end turn");
                                    current.attacked = current.attackCount;
                                    cursor += 1;
                                }
                            }else{
                                current.navFurther();
                            }
                        }


                    
                    }
                    
                }else{
                    console.log("Next turn, all actors moved")
                    resetTurn();
                    cursor = 0;
                }
            }

            next();

        }

        function resetTurn(){
            for(let actor of actors){
                actor.steps = 0;
                actor.moved = 0;
                actor.attacked = 0;
            }
        }

        function nextWave(){

            resetTurn();

            wave += 1

            if(wave % 5 === 0){
                game.storeItems = [];
                const n = rand(4);
                if(n === 0 || n === 1){
                    game.storeItems.push(items.items.randomKey());
                    game.storeItems.push(items.items.randomKey());
                    game.storeItems.push(items.items.randomKey());
                    game.storeItems.push(items.equipment.randomKey());
                }else if(n === 2){
                    game.storeItems.push(items.items.randomKey());
                    game.storeItems.push(items.items.randomKey());
                    game.storeItems.push(items.Abilities.randomKey());
                    game.storeItems.push(items.Abilities.randomKey());
                }else if(n === 3){
                    
                }
            }

            if(localStorage.furthest){
                const f = parseInt(localStorage.furthest,10);
                if(wave > f){
                    localStorage.furthest = wave;
                }
            }else{
                localStorage.furthest = wave;
            }

            if(wave > 10){
                wave = 1;
                if(area === 'Forest'){
                    area = 'Caves';
                }else if(area === 'Caves'){
                    area = "Village";
                }
            }

            const areas = {
                Forest:Object.keys(monsters.Forest),
                Caves:Object.keys(monsters.Caves),
                Village:Object.keys(monsters.Village),
            }

            if(wave % 5 === 0){

                //monsterRollOut.innerHTML += '<h3>Traveling Merchant</h3> Anything of interest? <br/><br/>';
                /*
                for(let i = 0; i < 4; i++){
                    const d = d4();
                    if(d === 0 || d === 1){
                        let keys = Object.keys(items.items);
                        const key = keys[Math.floor(Math.random()*keys.length)]
                        const item = items.items[key];
                        //monsterRollOut.innerHTML += `<b>${key}</b> ${item.type}, ${item.effect} - ${item.cost} / ${item.sell}<br/>`;
                    }else{
                        let keys = Object.keys(items.equipment);
                        const key = keys[Math.floor(Math.random()*keys.length)]
                        const item = items.equipment[key];
                        //monsterRollOut.innerHTML += `<b>${key}</b> ${item.stats}, ${item.special} - ${item.cost} / ${item.sell}<br/>`;
                    }
                }
                */

            }
            let first = true;
            let cc = wave;
            let monsterCount = 1;
            var qPlayerPos = getQuadraticPlayerPosition();
            while(cc >= 0){
                let next = areas[area][d6()];
                const monster = getMonster(next);
                if(cc - monster.cost >= 0  || first){

                    first = false;
                    spawnMonster(next);
                    monsterCount += 1;
                }
                cc -= monster.cost;
            }

            updateDisplay();
            render();
        }

        function spawnMonster(next){
            let a = d4();
            let b = d4();
            let c = d4();
            let l = 0;

            while(grid.quadraticGet(a,b,c) !== undefined && l < 9999){
                a = d4();
                b = d4();
                c = d4();
                l++;
            }

            let position = [a+1,b+1,c+1];
            const monsterInfo = document.createElement('span');
            //monsterInfo.innerHTML = `${monsterStats(next)} <br/> Position ${position[0]},${position[1]},${position[2]}`;
            const monster = getMonster(next);
            const gp = grid.quadraticToGrid(a,b,c);

            const actor = new BasePawn()
            actor.image = monster.image;
            actor.health = monster.hp;
            actor.maxHealth = monster.hp;
            actor.armor = monster.armor;
            actor.name = next;
            actor.iq = ({Dumb:1,mid:2,Smart:3})[monster.int]; //this is a cursed line of code lol
            console.log(monster.attack);
            const stats = parseWeaponStats(monster.attack);
            actor.attackDice = stats.damage;
            actor.attackRange = stats.range || 1;
            actor.attackRangeLoS = stats.los || false;
            actor.position = gp;
            actor.displayPosition.x = gp.x;
            actor.displayPosition.y = gp.y;
            actor.movementSpeed = monster.move;
            grid.set(gp.x,gp.y,actor);

            render();

        }

        function initials(name){
            const words = name.split(' ').join('_').split('_');
            return words.map(a => a[0]).join('');
        }

        document.body.addEventListener('mousemove',function(e){
            const x = vp.mouse.x;
            const y = vp.mouse.y;
            
            const gx = Math.floor(x/tileSize);
            const gy = Math.floor(y/tileSize);
            
            mouse.gx = gx;
            mouse.gy = gy;
            
            render();
        })

        canvas.addEventListener('mousedown',function(e){
            var rect = canvas.getBoundingClientRect();
            const x = mouse.x;
            const y = mouse.y;
            const gx = mouse.gx;
            const gy = mouse.gy;
            if(selected){
                const target = grid.get(gx,gy);
                
                if(target){
                    if(target == selected){
                        selected = false;
                        gridHighlights.setAll(false);
                        return;
                    }
                    selected.attemptAttack(target);
                    return;
                }
                if(gridHighlights.get(gx,gy) === 1){
                    gridHighlights.setAll(false);
                    selected.move(gx,gy);
                    if(selected.canMove()){
                        selected.showMoveGrid();
                    }
                }else if(gridHighlights.get(gx,gy) === 2){
                    gridHighlights.setAll(false);
                    const target = grid.get(gx,gy);
                    if(target.health !== undefined){
                        selected.attack(target);
                        if(selected.canAttack()){
                            selected.showAttackRange();
                        }else{
                            if(selected.canMove()){
                                selected.showMoveGrid();
                            }else{
                                selected = false;
                            }
                        }
                    }
                }

            }else{
                
                selected = grid.get(gx,gy);
                if(!selected || selected.ai > 0){
                    selected = false;
                    gridHighlights.loop((x,y,v) => {
                        gridHighlights.set(x,y,false);
                    });
                    return;
                }

                if(!selected.move){
                    selected = false;
                    return;
                }
                
                gridHighlights.loop((x,y,v) => {
                    gridHighlights.set(x,y,false);
                });
                
                if(selected){
                    if(selected.canMove()){
                        gridHighlights.floodFill(gx,gy,1,isSolidOccupied,1);
                    }else if(selected.canAttack()){
                        selected.showAttackRange();
                    }
                }

            }
        });

        function isSolidOccupied(x,y){
            if(x < 0 || x > 7) return true;
            if(y < 0 || y > 7) return true;
            if(grid.get(x,y)) return true;
            return false;
        }

        function isSolidOccupiedAttackable(x,y){
            if(x < 0 || x > 7) return true;
            if(y < 0 || y > 7) return true;
            const g = grid.get(x,y);
            if(g.health === undefined){
                return true
            }
            return false;
        }

        scene.start();
        nextTurn();

        function lookup(item){
            return item_lut[item];
            for(let type in items){
                if(items[type][item]){
                    return items[type][item];
                }
            }
        }

        function Game(){
            this.boundingWidth = tileSize * 8;
            this.boundingHeight = tileSize * 8;
            this.showBackpack = false;
            this.showEquipped = false;
            this.inStore = false;
            this.storeItems = [];
            this.tick = 0;
            this.render = function(ctx){
                render();
                //ctx.strokeRect(0,0,this.boundingWidth,this.boundingHeight);
            }
            this.update = function(delta){
                scene.camera.position.x = -canvas.width * 0.5;
                scene.camera.position.y = -canvas.height * 0.5;
                scene.camera.position.x += this.boundingWidth * 0.5;
                scene.camera.position.y += tileSize * 4;
            }
            this.renderUI = function(ctx){

                ctx.save();

                ctx.translate(0.5,0.5);

                ctx.font = '18px monospace';
                ctx.lineWidth = 2
                scene.ui.buttonWidth = tileSize * 2.5;
                scene.ui.buttonHeight = tileSize * 0.5;
                scene.ui.y = 5;
                scene.ui.x = 5;
                
                scene.ui.offsetDirection = vec2(1,0);
                scene.ui.textBG(area + ' - '+wave);
                scene.ui.text('game tick: '+game.tick);
                scene.ui.step(0,1);
                scene.ui.x = 5;
                

                if(player.ai > 0){
                    if(scene.ui.buttonUI("Disable Autoplay")){
                        player.ai = 0;
                        Mouse.left = false;
                    }
                }else if(scene.ui.buttonUI("Enable Autoplay")){
                    player.ai = 1;
                    Mouse.left = false;
                }

                if(scene.ui.buttonUI("Slot 1 - "+(player.slots[0]||'empty'))){
                    player.setWeapon(player.slots[0],0);
                    Mouse.left = false;
                    player.showAttackRange();
                };
                
                if(scene.ui.buttonUI("Slot 2 - "+(player.slots[1]||"empty"))){
                    player.setWeapon(player.slots[1],1);
                    Mouse.left = false;
                    player.showAttackRange();
                }

                scene.ui.x = scene.ui.buttonWidth + 5
                scene.ui.y = scene.ui.buttonHeight * 2 + 5;

                if(scene.ui.buttonUI("End Turn")){
                    gridHighlights.setAll(false);
                    selected.attacked = selected.attackCount;
                    selected.moved = selected.movementSpeed;
                    selected.note("End turn!")
                    Mouse.left = false;
                }
                
                scene.ui.buttonWidth = tileSize * 5;
                scene.ui.x = canvas.width - (5 + scene.ui.buttonWidth);
                scene.ui.y = scene.ui.buttonHeight;
                scene.ui.offsetDirection = vec2(0,1);
                
                if(game.storeItems.length > 0){
                    scene.ui.textBG('Mysterious Merchant');
                    for(let i of game.storeItems){
                        const item = item_lut[i];
                        scene.ui.buttonUI(i + ' - '+item.cost + ' - '+item.type);
                    }
                    if(scene.ui.buttonUI("Leave Store")){
                        game.storeItems = [];
                        Mouse.left = false;
                    };
                }

                scene.ui.buttonWidth = tileSize * 2.5;
                scene.ui.x = 5;
                scene.ui.y = 5 + scene.ui.buttonHeight * 2;

                scene.ui.spacing = 1;
                let columnCount = 1;

                if(scene.ui.buttonUI('Backpack')){
                    game.showBackpack = !game.showBackpack;
                    Mouse.left = false;
                };

                if(game.showBackpack){
                    scene.ui.x = 5;
                    scene.ui.y = scene.ui.buttonHeight * 3 + 5;
                    scene.ui.offsetDirection = vec2(0,1);

                    for(let name in playerInventory){

                        if(scene.ui.buttonUI( (playerInventory[name].selected?'> ':'')+name+': '+playerInventory[name].quantity)){
                            playerInventory[name].selected = !playerInventory[name].selected;
                            Mouse.left = false;
                        };

                        if(playerInventory[name].selected){
                            scene.ui.step(0.1,0);
                            if(items.equipment[name]){
                                if(scene.ui.buttonUI("Equip Slot 1")){
                                    player.setWeapon(name,0);
                                    playerInventory[name].selected = false;
                                    Mouse.left = false;
                                }
                                if(scene.ui.buttonUI("Equip Slot 2")){
                                    player.setWeapon(name,1);
                                    playerInventory[name].selected = false;
                                    Mouse.left = false;
                                };
                            }
                            if(items.Armor[name]){
                                if(scene.ui.buttonUI("Equip on "+items.Armor[name].slot)){
                                    
                                }
                            }
                            if(items.items[name] || items.Abilities[name]){
                                scene.ui.buttonUI("Use");
                            }
                            if(item_lut[name].sell && scene.ui.buttonUI("Sell")){
                                const item = lookup(name);
                                if(item){
                                    playerInventory[name].quantity -= 1;
                                    if(playerInventory[name].quantity <= 0){
                                        delete playerInventory[name];
                                    }
                                    playerInventory.gold = playerInventory.gold  || {quantity:0,selected:false};
                                    playerInventory.gold.quantity += item.sell;
                                    Mouse.left = false;
                                }
                            }
                            scene.ui.step(-0.1,0);
                        }
                        /*
                        if(scene.ui.y > tileSize * 8){
                            scene.ui.x += scene.ui.buttonWidth + tileSize * 0.25;
                            scene.ui.y = scene.ui.buttonHeight;
                            columnCount += 1;
                        }
                        */
                    }
                }
                
                this.boundingWidth = tileSize * 8// + columnCount * (scene.ui.buttonWidth + tileSize * 0.25);

                let y = 15;
                let x = canvas.width - 15;
                let i = 0;
                ctx.textAlign = 'right';
                ctx.fillText("Turn Order",x,y);
                y += 15;
                for(let actor of actors){
                    if(i === game.actorCursor){
                        ctx.fillText("=> "+actor.name,x,y);
                    }else{
                        ctx.fillText(actor.name,x,y);
                    }
                    y += 15;
                    i += 1;
                }
                y += 30;
                for(let i = 10; i >= 1; i--){
                    let item = messageLog[messageLog.length-11+i];
                    ctx.fillText(item||'',canvas.width - 10,y);
                    y += 20;
                }
                ctx.restore();


            }
        }

    </script>
</body>
</html>